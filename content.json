{"pages":[{"title":"friends","text":":)","link":"/friends/index.html"}],"posts":[{"title":"[blog] hexo admin plugin 으로 포스트 작성","text":"블로그 포스팅하기github.io로 블로그를 만드는 많은 이용자들이 프래임워크를 활용을 하게된다.필자와같이 hexo를 사용하기도 하고, jekyll을 사용하기도한다.프래임워크마다 지원하는 기능이나 플러그인은 다를 수 있지만 포스팅을하는 기능이나, 테마를 바꾸는 기능처럼 공통적인 부분은 기본적으로 지원한다. 본 글에서는 필자가 블로그 포스트를 작성하는 방법에 대해 소개를한다.블로그에 관한 다른내용이 궁금하다면 아래 내용을 참고하도록 하자. 관련 포스트 hexo로 블로그만들기 블로그 테마 입히기 포스팅markdown github repository를 만든 후 안내를위해 readme.md를 작성하는경우. github.io로 만든 블로그의 기본구성에서 포스트 작성하는 방식. 공통점은 모두 markdown(마크다운) 문법을 사용한다는 것이다.markdown 문법은 매우 간결하며 html의 많은 문법들을 대체할 수 있다.복잡한 기능없이 쉽고 빠르게 글을 쓰는경우 많이들 사용한다. 예시1 h1-h6html 에서 h1~h6 을 나타내는 문법123456# 제목 1## 제목 2### 제목 3#### 제목 4##### 제목 5###### 제목 6 예시2 목록1234- 순서가 필요하지 않은 목록에 사용 가능한 기호 - 대쉬(hyphen) * 별표(asterisks) + 더하기(plus sign) 그외링크,이미지,테이블,코드, 코드블럭 등 다양한 문법이 준비되어있다.자세한 사항은 아래 링크를 참고하도록하자 https://gist.github.com/ihoneymon/652be052a0727ad59601 작성도구문서를 작성할때는 에디터 프로그램을 사용하는것이 일반적이다. 물론 메모장에서 작성해도 상관 없지만 도구는 문서를 작성할때 많은 도움을 준다.아래 소개할 도구들은 작성을 편리하게 해 줄 뿐 아니라, 작성한 결과도 함깨 표시해주어 마크다운으로 문서를 작성할때 추천한다. atomhttps://atom.io atom 은 가볍기도하고, 다양한 테마가 있어 원하는 취향대로 쓸 수 있다.github도 연동이되어 내가 작성한 문서의 버전관리도 쉽게 연동 가능하다. 하지만 이미지 첨부의 경우 난감해진다.이미지를 포스트에 보여주기위해서는 link가 필요하다. 이경우 원하는 경로에 이미지를 넣고 상대경로를 링크로 걸어준다예를들면 위 atom 에디터의 이미지는 아래처럼 되어있다. 1![atom](/images/pasted-31.png) 필자는 이미지업로드를 편하기위해 hexo admin plugin을 사용한다. admin pluginhexo plugin 소개hexo 에는 다양한 플러그인이 있다. (https://hexo.io/plugins/) 블로그의 uv/pv를 측정해주는 기능. rss생성 이미지 갤러리생성 검색을위해 robot.txt생성 .. 그 중 admin plugin은 포스팅을 쉽게 할 수 있도록 만들어졌으며 테그와 카테고리등록도 쉽게 할 수 있다. 설치아래 github 주소의 의 공식 가이드에 맞추어 진행하였다.https://github.com/jaredly/hexo-admin blog를 초기화한 root 경로로 이동한다음 아래 명령어를 수행해준다123npm install --save hexo-adminhexo server 그리고 hexo server 를 실행하여 로컬에 서버를 띄운후http://localhost:4000/admin으로 들어가준다 자동으로 만들어진 하나의 포스트가 보인다. 새로운 포스트 만들기먼저 좌측 상단 posts탭에서 파란색 + NEW POST 를 누르고 제목을 입력한다. 그리고 마크다운문법으로 글을 작성한다. 이때 작성한 글은 변화를 감지하여 자동으로 저장되며 작성한 내용을 바로 볼 수 있다.이미지의경우 원하는 이미지를 복사한 상태로 본문으로 커서를옮겨 붙여넣으면 이미지가 경로에 업로드되면서, 본문에 이미지 문법으로 작성까지 한번에 된다. 태그와 카테고리본문을 모두 작성하였으면 태그와 카테고리를 설정 할 수 있다.우측애 기어처럼 생긴 버튼을 누르고 태그와 카태고리를 입력한다. 마지막으로 오른쪽 빨간색 publish 버튼을 누르면 준비는 모두 끝났다. 배포하기이제 실제 블로그에 올라갈 단계이다. 목표는 배포 저장소인 github repository에 올리는것이다. 배포단계는 공식 문서를 참고하였다. (https://hexo.io/ko/docs/one-command-deployment) hexo blog home 디렉토리로 이동후 _config.yml을 열고 deployment 항목을 작성한다. 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 그리고 hexo g &amp;&amp; hexo d 명령어를 수행한다. hexo g : hexo generate 의 약자로 작성한 본문의 내용을 바탕으로 웹페이지생성 hexo d : hexo deploy 의 약자로 생성된 페이지를 저장서로 배포 보안admin의 경우 포스트를 생성/삭제 할 수 있는만큼 로컬서버에서는 기능이 작동하지만, 실제 배포후에는 404에러가 나와서 접근이 불가능하여 관리가 용의하다. 아이디와 비밀번호도 수동으로 셋팅 할 수 있는데 http://localhost:4000/admin/#/auth-setup 에서 아이디와 비밀번호의 hash값을 생성하고, _config.yml에서 값을 설정한다자세한것은 공식문서 를 참고하자","link":"/2020/02/19/Hexo-admin-plugin/"},{"title":"[blog] Hexo icarus 테마 적용하기","text":"테마블로그에서 테마라고 하면 작게는 글자 폰트,크기,색부터 시작하여 헤더와 푸터 그리고 좌우 사이드 메뉴의 구성과 크기까지라고 여러가지 요소가 있다.테마가 중요한이유는 사용자에게 제일 먼저 다가오는 이미지를 좌우하기 때문에다. 심플하다, 화려하다, 실용적이다… 목적에 따라 그리고 작성자의 취향에따라 선택할수 있는 폭도 넓다. hexo themehexo 공식 홈페이지에 등록된 테마는 2020-02월 기준으로 약 300개가량 되고 이를 적용하면 아주 간단하게 테마를 적용 할 수 있다 먼저 아래 홈페이지에서 마음에 드는 테마를 하나 선택하도록하자.개발자를 위한 테마도 있지만, 사진이나 동영상블로그를 하는분들을 위한 테마도 다양하게 준비되어있다.이번 글에서는 이 블로그에 적용되어있는 icarus라는 테마를 기준으로 설명한다. https://hexo.io/themes/ icarus theme일반적으로 테마는 오픈소스로 git으로 관리하는 경우가 많다. icarus 테마의 경우도 마찬가지이다. git repository에 들어가보면 해당 테마의 적용방법이 소개되어있고, 설정을 할 수 있도록 공식 문서가 준비되어있는 경우가 일반적이다. issue탭에서는 궁금한점이나 공식문서에 나와있지 않은것들도 질문할 수 있다. https://github.com/ppoffice/hexo-theme-icarus A simple, delicate, and modern theme for the static site generator Hexo. 적용방법파일 다운로드적용방법은 모든 hexo theme가 동일하다. hexo init 에서 생성된 폴더중 theme에 해당 테마의 코드를 clone 받는다. 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 이후 theme 폴더 내부에는 icarus라는 폴더가 생성되어있는것을 볼 수 있다. 테마 변경 설정이전 블로그 만들기 포스팅에서 진행된 상황에서는 기본으로landscape라는 테마가 설정되어있다. 새로 받은 icarus테마로 변경해보자.이 또한 매우 간단하다. 먼저 git page home 디랙토리에 있는 _config.yml 파일을 연다. 그리고 theme : landscape 라고 설정되어있는 분을 찾아 icarus로 변경한다 _config.yml1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 실행해보기 &amp; 라이브러리 오류수정hexo server 명령어를 통해 잘 변경되었는지 확인해보자. icarus 라는 로고가 올라오는것을 보니 설정은 잘 되었다는것을 알 수 있다.테마들은 각자 구성에 필요한 라이브러리의 종류가 다르다. 의존성을 가지는 라이브러리가 설치가 되어있지않은 경우 오류가 날 수 있고. 필자의경우 cheerio 라는 라이브러리가 필요했다. git page home 디렉토리에 돌아가서 npm install cheerio 를 실행해주자.이후 hexo server를 실행하면 themes/icarus/_config.yml파일을 생성한다는 메시지가 나오고,한번더 실행하면 localhost:4000으로 성공적으로 실행된다. 테마 입맛대로 바꾸기테마는 기본적인 구성일 분 블로그 운영자가 원하는대로 바꿀 수 있어야한다.각 테마의 공식 문서를 확인 하면서 바꾸는것이 정석이라고 할 수 있다. icarus테마에서는 themes/icarus/_config.yml 파일을 수정하여 원하는 대부분기능을 수행 할 수 있다.widget만 어느정도 설정하면 겉으로보이는 테마설정은 거의 마무리되었다고 보아도 된다. widget (sidebar)icarus테마에서 왼쪽 오른쪽에 있는 박스영역을 widget이라고 부르며 설정에서 이 항목들을 제어할수 있다.사용할 항목이라면 이름과 위치(왼쪽, 오른쪽)을 필수로 입력한다. 사용하고싶지 않다면 해당항목을 지우도록 하자. 위치 이 외에 세부적으로 설정할 수 있는것은 2가지이다. profile가장 먼저 자신을 알릴수 있는 프로필이다. 공식문서는 다음 url을 참고하도록 하자.https://blog.zhangruipeng.me/hexo-theme-icarus/Widgets/profile-sidebar-widget/ link링크항목같은경우 필자는 사용하고있지않다. 이또한 공식문서를 참고하도록하자.https://blog.zhangruipeng.me/hexo-theme-icarus/Widgets/links-sidebar-widget/ 추가사항이외에 광고나 댓글같은경우는 별도의 포스트를 준비할 예정입니다.겉으로 보이지 않는 web master도구나, google analytics또한 준비예정입니다sidebar의 폭설정이나 로고변경같은 세부적인 내용은 넣지않았습니다. 궁금한경우 댓글로 남겨주시면 감사하겠습니다.","link":"/2020/02/10/Hexo-theme-icarus/"},{"title":"Intellij 느릴때 - 메모리 할당량 늘리는법","text":"intellij 를 사용하다보면 느려지는경우가 발생한다.검색할때 버벅이거나 커서가 바로 이동하지 않는등 불편함이 따른다.사용하는 pc의 메모리가 충분하다면, intellij의 메모리 할당량을 늘려서 개선해보도록 하자. 예시는 기본값인 750M -&gt; 2048M 으로 변경하였다.무조건 높은 메모리를 할당하기보다는, 개인의 개발환경에 맞는 메모리 셋팅이 필요하다. 2020.2 버전 업데이트로 Memory 할당량과, Indicator 설정방법이 변경되었습니다.아래 링크를 참고해주세요.Intellij 느릴때 - 메모리 할당량 늘리는법 (2020.2 업데이트버전) 방법 1. intellij 메뉴에서 바로 변경 [Help] - [Edit Custom VM Options…] Xms, Xmx 수치를 변경 IntelliJ 재시작. 123456-Xms256m-Xmx2048m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50.... 방법 2. toolbox 사용JetBrainsToolbox 소개jetbrains toolbox는 jetbrain의 프로그램들을 관리하는 프로그램이다.업데이트 내역, 설치현황등을 한눈에 볼 수 있다.소개 :https://blog.jetbrains.com/kr/2017/06/toolbox-app을-소개합니다/ 메모리 할당량 늘리기 toolbox에서 intellij 선택 setting 창 열기 원하는 값으로 메모리설정 (기본값은 750) 늘어난 매모리를 확인하기IntelliJ실행후 우측아래 memory indicator 확인. 보이지 않는경우 [File] - [Settings]에서 ‘show memory indicator’로 검색 -&gt; 체크 V or [File] - [Settings] - [Appearance &amp; Behavior] - [Appearance] - Show memory indicator -&gt; 체크 V","link":"/2019/02/08/Intellij-%EB%8A%90%EB%A6%B4%EB%95%8C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9%EB%9F%89-%EB%8A%98%EB%A6%AC%EB%8A%94%EB%B2%95/"},{"title":"JMH로 자바 성능측정 비교하기 - java performance","text":"성능측정 과제 Map, Set, List, Queue 의 성능은 어떨지 알아보기 실험을 통해 Map / List 성능 측정 JMH 기본적인 사용법 (시작하기)아래와 같은 명령어를 사용해 maven project를 생성한다1234567mvn archetype:generate \\ -DinteractiveMode=false \\ -DarchetypeGroupId=org.openjdk.jmh \\ -DarchetypeArtifactId=jmh-java-benchmark-archetype \\ -DgroupId=org.sample \\ -DartifactId=test \\ -Dversion=1.0 성능 측정 코드 작성 (아래에서 계속) mvn clean install 로 빌드 java -jar target/benchmarks.jar 로 성능측정 Map, Set, List, Queue 차이점위 4가지는 Java에서 사용 가능한 Collection이고 데이터를 모아서 사용한다는 점에서 비슷하지만 차이가 있다. MapMap&lt;K,V&gt; key 와 value 쌍으로 이루어져 있어서 두개의 값을 mapping 하는 용도로 많이 사용한다. 쉽게 생각하면 database에 attribute 가 1개밖에 없는 table이다. key 값을 넣으면 value 를 리턴해 준다. 개인적으로 구현체로는 주로 HashMap을 쓰며 , Map&lt;String,String&gt; = new HashMap&lt;&gt;() 처럼 사용 Set,List,Queue이 3가지를 분리 한 이유는, 이 모두 Map과 다르게 쌍이 아닌 데이터 자체를 모으기 때문이다. 하지만 세부적인 기능은 다르다. List 순서가 있는 데이터를 저장 할 때 사용 같은 값의 데이터가 들어와도 다른 index에 저장이 된다. ArrayList, LinkedList.. Set ‘집합’ 이라는 뜻을 가짐 중복을 허용하지 않는다, 데이터를 넣을때 이미 같은 값을 저장하고 있는 경우 저장하지 않음 출력 할때도 어떤 순서로 출력될지 모른다! Queue FIFO 이다 (Stack - FILO) add, poll 같은 함수를 사용한다 https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html 참고 - java 에서 제공하는 라이브러리로 자세한 사항은 여기서 확인 할 수 있다 JMH 를 사용하여 List 추가/조회/삭제 성능측정 option : 12@BenchmarkMode(Mode.AverageTime)@OutputTimeUnit(TimeUnit.NANOSECONDS) 추가123456789101112131415161718@Benchmarkpublic void addIntoArrayList() { List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { arrayList.add(&quot;Hello&quot;); }}@Benchmarkpublic void addIntoLinkedList() { List&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { linkedList.add(&quot;Hello&quot;); }} 조회(랜덤)12345678910111213141516171819@Benchmarkpublic void searchArrayList(State state) { List&lt;String&gt; arrayList = state.arrayListForSearch; int number = (int) (arrayList.size()%Math.random()); for (int i = 0; i &lt; 100; i++) { arrayList.get(number); }}@Benchmarkpublic void searchLinkedList(State state) { List&lt;String&gt; linkedList = state.LinkedListForSearch; int number = (int) (linkedList.size()%Math.random()); for (int i = 0; i &lt; 100; i++) { linkedList.get(number); }} 삭제(랜덤값)12345678910111213141516171819@Benchmarkpublic void deleteFromArrayList(State state) { List&lt;String&gt; arrayList = new ArrayList(state.arrayListForSearch) ; int number = (int) (Math.random()%arrayList.size()); for (int i = 0; i &lt; 10; i++) { arrayList.remove(number); }}@Benchmarkpublic void deleteFromLinkedList(State state) { List&lt;String&gt; linkedList = new ArrayList(state.LinkedListForSearch); int number = (int) (Math.random()%linkedList.size()); for (int i = 0; i &lt; 10; i++) { linkedList.remove(number); }} JMH 를 사용하여 Map 추가/조회/삭제 성능측정추가1234567891011121314151617@Benchmarkpublic void addIntoHashMap() { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { hashMap.put(i + &quot;&quot;, &quot;Hello&quot;); }}@Benchmarkpublic void addIntoTreeMap() { Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { treeMap.put(i + &quot;&quot;, &quot;Hello&quot;); }} 조회(랜덤)12345678910111213141516171819@Benchmarkpublic void searchHashMap(State state) { Map&lt;String, String&gt; hashMap = state.hashMapForSearch; int number = (int) (Math.random()%hashMap.size()); for (int i = 0; i &lt; 100; i++) { hashMap.get(number + &quot;&quot;); }}@Benchmarkpublic void searchTreeMap(State state) { Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;(); int number = (int) (Math.random()%treeMap.size()); for (int i = 0; i &lt; 100; i++) { treeMap.get(number + &quot;&quot;); }} 삭제(랜덤값)123456789101112131415161718192021@Benchmarkpublic void deleteFromHashMap(State state) { Map&lt;String, String&gt; hashMap = new TreeMap(state.hashMapForSearch); int number = (int) (Math.random()%hashMap.size()); for (int i = 0; i &lt; 10; i++) { hashMap.remove(number + &quot;&quot;); }}@Benchmarkpublic void deleteFromTreeMap(State state) { Map&lt;String, String&gt; treeMap = new TreeMap(state.TreeMapForSearch); for (int i = 0; i &lt; 10; i++) { int number = (int) (Math.random()%treeMap.size()); treeMap.remove(number + &quot;&quot;); }} 참고 자료 샘플코드 - http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/ Java Performance Tuning Guide - http://java-performance.info/jmh/ Code Tools: jmh - http://openjdk.java.net/projects/code-tools/jmh/ 자바성능 튜닝 이야기 - 이상민 지음","link":"/2017/01/15/JMH%EB%A1%9C-%EC%9E%90%EB%B0%94-%EC%84%B1%EB%8A%A5%EC%B8%A1%EC%A0%95-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0-java-performance/"},{"title":"QueryDsl 적용 가이드 (SpringBoot-gradle-멀티모듈-JPA)","text":"spring boot2.x / gradle /jpa 환경을 가정하였습니다. //TODO : 자세한설명추가 Plugin 추가하기 멀티모듈 프로젝트로 가정했습니다상위 프로젝트에서 플러그인을 셋팅했습니다. build.gradle (멀티모듈 상위 에다가 셋팅함) 12345678910ext { springBootVersion = '2.0.5.RELEASE' querydslPluginVersion = '1.1.7' //이부분}... dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) classpath(&quot;gradle.plugin.com.ewerk.gradle.plugins:querydsl-plugin:${querydslPluginVersion}&quot;)} 의존성 추가 / queryDSL 빌드설정 추가 queryDSL을 사용할 모듈의 build.gradle에서 셋팅 build.gradle 12345678dependencies { compile (&quot;com.querydsl:querydsl-core:4.2.1&quot;) compile (&quot;com.querydsl:querydsl-apt:4.2.1&quot;) compile (&quot;com.querydsl:querydsl-jpa:4.2.1&quot;)}apply from: &quot;$projectDir/queryDsl.gradle&quot; //아래 작성한 내용 import queryDsl.gradle 1234567891011121314151617// querydsl 적용apply plugin: &quot;com.ewerk.gradle.plugins.querydsl&quot; // Plugin 적용def querydslSrcDir = 'src/main/generated' // QClass 생성 위치querydsl { library = &quot;com.querydsl:querydsl-apt&quot; jpa = true querydslSourcesDir = querydslSrcDir}sourceSets { main { java { srcDirs = ['src/main/java', querydslSrcDir] } }} QueryDsl 빌드 생성된 Entity 확인위에서 설정한 QClass 경로에 잘 생성되었는지 확인src/main/generated 소스코드작성XXXRepogitoryCustom, XXXRepogitoryCustomImpl 작성queryDSL로 짜고싶은 쿼리를 사용할 인터페이스 XXXRepogitoryCustom 123public interface BrandRepositoryCustom { Collection&lt;Brand&gt; findAllBrand();} 구현체 작성XXXRepogitoryCustomImpl 1234567891011121314151617181920public class BrandRepositoryCustomImpl extends QuerydslRepositorySupport implements BrandRepositoryCustom { QBrand brand = QBrand.brand; QBrandPinPolicy brandPinPolicy = QBrandPinPolicy.brandPinPolicy; QBrandMerchant brandMerchant = QBrandMerchant.brandMerchant; public BrandRepositoryCustomImpl() { super(Brand.class); } public Collection&lt;Brand&gt; findAllBrand() { return from(brand) .innerJoin(brand.brandPinPolicy, brandPinPolicy) .fetchJoin() .leftJoin(brand.brandMerchant, brandMerchant) .fetchJoin() .fetch(); }} JPA repogitory에서 상속 1234public interface BrandRepository extends JpaRepository&lt;Brand, String&gt;, BrandRepositoryCustom { Brand findBrandByBrandCode(String brandCode);} 로직에서 사용하기 123public Collection&lt;Brand&gt; getBrandAll() { return new LinkedHashSet&lt;&gt;(brandRepository.findAllBrand());} 구조123456789101112interface XXXXRepositoryinterface XXXXRepositoryCustominterface JpaRepository class XXXXRepositoryImplclass XXXXServiceXXXXRepository &lt;|- JpaRepository : extendsXXXXRepository &lt;|- XXXXRepositoryCustom : extendsXXXXRepositoryCustom --&gt; XXXXRepositoryImpl : implments XXXXService &lt;-- XXXXRepository : DI","link":"/2020/06/15/JPA-QueryDsl/"},{"title":"Spring-boot 주기적으로 코드 실행하기 @Scheduled","text":"스프링 부트에서 일정 시간 주기적으로 작업하는 스케쥴러를 만들어보려고 한다 @EnableScheduling 추가하기 @EnableScheduling 주석은 응용 프로그램의 스케줄러를 활성화하는 데 사용된다 기본 스프링 부트 애플리케이션 클래스 파일에 추가해야 한다 1234567@SpringBootApplication@EnableSchedulingpublic class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); }} 주기설정crontab 방식으로 주기를 설정할때 표현식은 아래링크를 참고https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm @Scheduled 추가하기 @Scheduled 특정 기간 스케줄러를 트리거하는 데 사용한다 123@Scheduled(cron = &quot;0 * 9 * * ?&quot;)public void cronJobSch() throws Exception {} 아래 예제는 매일 오전 9 시부 터 오전 9시 59 분까지 매분마다 작업을 실행하는 방법을 보여주는 샘플 코드이다. 12345678910111213141516import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class Scheduler { @Scheduled(cron = &quot;0 * 9 * * ?&quot;) public void cronJobSch() { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); Date now = new Date(); String strDate = sdf.format(now); System.out.println(&quot;Java cron job expression:: &quot; + strDate); }} @Scheduled fixedRate 고정된 주기로 실행하기 @Scheduled(fixedRate = 1000) 처럼 사용하면 특정 주기로 실행가능하다 완료되는것을 기다리지 않고 실행한다 단위는 ms 123@Scheduled(fixedRate = 1000) public void fixedRateSch() { } 아래와 같이 구현할 경우 이전 작업이 완료 될 때까지 기다린다 123@Scheduled(fixedDelay = 1000, initialDelay = 1000)public void fixedDelaySch() {}","link":"/2020/01/15/Spring-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0-Schedule/"},{"title":"Maven Profile 을 통해 설정 관리하기 &#x2F; Spring profile","text":"필요성아주 작은 프로젝트, 절대로 변하지 않을 프로젝트라면 상관없다. 하지만 단순히 서비스를 어느서버에서 하느냐, 디비를 어느것을 이용하느냐, 인증을 어디것을 사용하느냐에 따라 코드를 바꿔야 한다.자주 바뀌는 코드, 코드말고 다른 의존성에 의한 설정값 등의 셋팅이 코드에 있다면 어떤 일이 발생할까? 기존값을 주석처리하고 원하는 값으로 수동으로 바꾸는등 수작업이 필요하며 이런 데이터가 많을수록 작업 효율이 떨어진다. maven profile spring profile 두가지를 활용해 원하는 리소스를 활용하는 방법에 대해 알아보자. ex1 DB connection 설정mysql 데이터 베이스를 연동하기위한 설정부분이다 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:ServerAddress:13306/letsparty?characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;id&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;pass&quot;/&gt;&lt;/bean&gt; driverClassName은 그렇다 쳐도, url의 경우는 local,dev,release,test 와같은 상황에 따라 바뀐다.상황에 따라 수동으로 입력 하는것은 매우 번거러운 일이다. 선택필자가 개발하는 팀에서는 local,alpha,beta,release 상황에 따라 바뀌는 설정들을 미리 정해놓고, 컴파일 타임에 선택하려 한다. 후보는 아래 2가지가 있다 maven profile spring profile Spring profilespring profile의 특징은 런타임에 profile을 바인딩하여 설정 할 수 있는 것이다. 123456789101112131415@Configurationpublic class AppConfig { @Profile(&quot;dev&quot;) @Bean public CacheManager cacheManager() { //... } @Profile(&quot;live&quot;) @Bean public EhCacheManagerFactoryBean ehCacheCacheManager(){ //... } @Profile(&quot;testdb&quot;) @Bean public DataSource dataSource() { //... }} @Profile 을 통해 적용되는 코드를 나누고, web.xml에서 다음과 같은 설정을 통해 profile을 설정한다.1234&lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;alpha&lt;/param-value&gt;&lt;/context-param&gt;혹은 콤마로 구분하여 어러개를 넣을 수 있다.1234&lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;local, testdb&lt;/param-value&gt;&lt;/context-param&gt; java로 실행한다면 -DSpring.profiles.active 로 삽입할수도 있다. maven profilemaven 을 통한 profile 관리는 compile 시점에 mvn -P[profileName] clean package 명령어를 통해 어떤 자원을 사용할지 결정한다. profile 설정파일들이 들어갈 폴더구조를 만든다. profile에 해당하는 resource 폴더구조를 적어준다 pom.xml123456789101112131415161718192021222324252627282930313233343536&lt;project&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;local&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;environment&gt;local&lt;/environment&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;real&lt;/id&gt; &lt;properties&gt; &lt;environment&gt;real&lt;/environment&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;environment&gt;dev&lt;/environment&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/${environment}&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; maven profile 사용하기property로 뺄 부분을 별도의 파일로 만든다그리고 위 사항을 .java 나 .xml 에서 사용한다. 변수에서 사용12345@Value(&quot;#{'url'}&quot;)String url; @Value(&quot;#{path}&quot;) String path; xml 설정에서 사용mysql.properties1234jdbc.driver = com.mysql.jdbc.Driver jdbc.url = jdbc:mysql://localhost:3306/hellojdbc.username = idjdbc.password = passward 123456789101112131415&lt;bean class= &quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot; &gt; &lt;property name= &quot;locations&quot;&gt; &lt;value&gt;classpath:/mysql.properties&lt;/value &gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class= &quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot; &gt; &lt;property name= &quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot; /&gt; &lt;property name= &quot;url&quot; value =&quot;${jdbc.url}&quot; /&gt; &lt;property name= &quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name= &quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;","link":"/2017/01/23/Maven-Profile-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/"},{"title":"chrome80 바뀐 cookie 정책 대응하기 ( SameSite&#x3D;none)","text":"chrome80크롬 80버전부터 새로운 쿠키 정책(SameSite Cookie)이 시행될 예정이다.이 정책이 시작되면 어떤 영향도가있는지, 어떻게 대응해야할지 알아보자 바뀐 쿠키정책목적 CSRF ( cross-site-request-forger ) 공격을 막기 위해 third-party 쿠키를 막으려는것이 기본 컨셉이다. 이를 위해 cookie 정책중 samesite의 기본값을 바꾼다. 하지만 이렇게되면 오류가 매우 많이 발생할수 있으니 top-level navigation일 경우에는 third-party cookie를 허용해주는 Lax를 기본값으로 한다.chrome79 에서는 samesite 기본값이 None으로 되어있으나 chrome80 부터는 Lax가 된다. 영향도cookie값을 읽는데 영향이 생긴다. cookie값은 서로다른 사이트에서 정보를 주고받는데 많이 사용한다.대표적으로는 로그인과 사용자 식별을 예로 들 수 있다. 많은 사이트들이 쿠키에 로그인에 대한 정보를 담은 token값을 저장하고, 이값으로 로그인여부판단과 사용자식별을 한다.만약 cookie값을 읽지 못한다면 로그인후 셋팅된 token값을 읽지못해 로그인이 실패하는 현상이 생길것이다. 그럼 samesite가 무엇이고, 어떤 정책을 가지고있는지 그리고 chrome80에서 주의할점을 알아보자 시기2020년 2월 4일부터 Chrome 80 배포 예정이다.이 전에 대응해야 업데이트한 사용자에게 서비스를 정상적으로 제공 할 수 있다. SameSite Cookiecookie 를 읽을수 있는 대상을 명확하게 하는것이 주 목적이라고 볼 수 있다.정책별로 어떤점이 다른지 알아보자 SameSite 정의 chrome 80이후 버전 주의점 Strict 사용자가 직접 주소창에 입력하는 top-level navigation을 제외한 모든 요청에 Cookie가 포함되지 않는다.즉, Strict는 쿠키를 사이트 간에 사용할 수 없게 차단합니다.이 옵션은 은행과 같이 보안이 높은 애플리케이션에 가장 적합합니다. link, Form Get, Form Post, iframe, ajax, img를 통해 다른 domain request 요청시 쿠키 전달 안됨ex) Form Postb.com에서 쿠키가 구워진 상태에서 a.com site에서 Form Post로 b.com으로 submit할때 b.com의 http request에서 쿠키를 읽을 수가 없다. Lax Cookies with this setting are sent only on same-site requests or top-level navigation with non-idempotent HTTP requests, like HTTP GET따라서 이 옵션은 타사에서 쿠키를 사용할 수 있지만 CSRF 공격의 피해를 당하지 않도록 하는 보안 혜택이 추가된 경우에 사용됩니다. chrome 80 부터 DefaultForm Post, iframe, ajax, img를 통해 다른 domain request 요청시 쿠키 전달 안됨 : 사용자가 주소창에 주소가 변경되는걸 확인 할 수 있는 경우만 쿠키 전달을 허용하는 것으로 이해됨ex) iframeb.com에서 쿠키가 구워진 상태에서 a.com에서 b.com site를 iframe으로 포함할 경우 b.com의 쿠키를 iframe인 b.com에서 읽을 수가 없다. None 기존에 사용하던 Default설정 Cookies without SameSite must be secure 설정이 enable상태에서 Secure특성을(https강제) 태깅하지 않으면 쿠키를 전달하지 않습니다.(다른 도메인을 가진 iframe내에서는 lax나 strict는 신규로 구워지지 않음)https://www.chromium.org/updates/same-site/incompatible-clientssafariMacOS 10.14의 Safari 및 내장 브라우저 및 iOS 12의 모든 브라우저SameSite = None`으로 표시된 쿠키를`SameSite = Strict`로 표시된 것처럼 잘못 취급합니다. 이 버그는 최신 버전의 iOS 및 MacOS에서 수정되었습니다chromeChrome 51에서 Chrome 66까지의 Chrome 버전 (양쪽 모두 포함)이 Chrome 버전은`SameSite = None`의 쿠키를 거부합니다. 이는 Android WebView뿐만 아니라 이전 버전의 Chromium 파생 브라우저에도 영향을줍니다Chrome 51 이전에는 SameSite 속성이 완전히 무시되었으며 모든 쿠키는 마치 ‘SameSite = None’으로 취급되었습니다. 더 자세한 내용은 아래 링크를 참고하자 https://blog.chromium.org/2019/10/developers-get-ready-for-new.html https://docs.adobe.com/content/help/ko-KR/target/using/implement-target/before-implement/privacy/google-chrome-samesite-cookie-policies.translate.html 대처법정책정하기가장 먼저 할 일은 정책을 정하는것이다.SameSite설정이 없는 경우 Lax가 Default 설정이 된다.위 sameSite 설정에관한 내용을 읽어보고 자신이 하고있는 서비스의 쿠키정책을 Lax로 할것인지, None으로 할것인지 의논하여 정하자 SameSite Nonechrome80 이 점차적으로 보급됨에따라서 Cookies without SameSite must be secure 설정이 점차적으로 상승할것이다.None으로 사용하고싶다면 모든 요청을 https인지 점검하고 Secure tag를 꼭 함께 사용해야 합니다..None을 더이상 사용하지 않겠다면 Default 설정이 될 Lax의 내용을 확인하자 SameSite Lax같은 Domain설정을 사용한다면 문제가 되지 않는다 (ex: *.domain.com를 사용하는 모든 sub domain)다른 domain(shop.com)을 사용하는 곳에서 쿠키를 구운 도메인(id.com)을 호출하는 경우 shop.com에서 id.com을 호출하는 방식에 따라서 브라우저가 id.com에 이전에 구워 놓은 쿠키를 전달하지 않는다. 추가적으로 쿠키를 다음 방식으로 호출시 쿠키값을 전달하지 않는다 Form Post iframe ajax img 대표적인 예로는 쇼핑몰에서 소셜회원으로 로그인을 한다면, 소셜서비스 도메인의 페이지에서 회원인증후 쿠키를 굽고, 이후 쇼핑몰에서 그 쿠키를 확인하는 방식으로 동작할것이다. 이경우 쿠키를 읽는데 실패할것이다. SameSite strictLax와 동일하지만 쿠키를 전달하지 않는 호출 방식이 다양하다. Link Form Get Form Post iframe ajax img 대처법sub domain으로만 서비스 하는 경우는 Lax정책이 default가 되더라도 큰 영향이 없다.다른 도메인 서비스와 정보를 주고받는 경우 SameSite 정책을 None으로 가져가야하며, 이 쿠키를 사용하는 모든 서비스에서는 이에 대응해야한다 쿠키를 굽는 서비스쿠키를 구울때 SameSite=None 옵션을 주어서 굽도록 한다 쿠키를 읽는 서비스https 통신하기https통신을 하는 경우만 쿠키값을 읽을수 있으므로 모든서비스가 https통신을 할 수 있게 준비해야한다. 저자가 담당하는 서비스에서는 크게 2가지로 나누어 대응하였다 apache / nginx 에서 http로 요청시 https로 redirect 우선은 모든 서비스가 쿠키값을 읽을 수 있도록 https서비스를 하도록 하였다. image file, 등 static resource를 상대경로로 바꾸기 모든서비스가 https 로 동작하게되기때문에 리소스에 http로 절대경로가 적혀있다면 오류가 발생할 수 있다. 때문에 모든 리소스의 주소를 상대경로로 바꾸었다","link":"/2020/02/05/chrome80/"},{"title":"JPA-DDD 1 프로젝트 시작하기 - 1","text":"시작하기전에 DDD / JPA기반의 프로젝트를 처음 도입하며 고민한 내용을 모아보았습니다. 모든 예제를 자세하게 다루지는 않습니다.구체적인 예시보다는 방향성을 중점으로 봐주시면 감사하겠습니다.같이 작업한 전OO님과 많은 의논을하며 공부했습니다. 감사합니다 의존성12345dependencies { ... compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;) ...} DOMAIN 모델링 - 방향설정하기 ★★★★ 방향을 잘못정하면 관계가 복잡해진다 -&gt; DDD의 의도와 맞지않음 책임 관계가 모호해진다 …. 자세한 권한설정및 방향은 뒤에서 다룸. 예제공장에서 만든 제품을 매장에 공급한다고 가정 방향설정 정책 정하기1. 핵심이 되는 도메인이 무엇인지 설정하기 -&gt; root 에그리거트로 root 에그리거트가 책임을 가지는 영역을 정한다 root -&gt; 하위도메인 방향으로만 제어할것 하위에서는 key만 가지고가기(1:n) one to one 에는 논란이있음 -&gt; 뒤에서 설명함 2. root 에그리거트끼리의 참조 root 에그리거트끼리는 서로 참조하지 않는것을 원칙으로한다. (알고있다는 의존관계를 최소화) 참조가 반드시 필요하다고 생각된다면 방향성도 단방향으로 고려한다 다른 에그리거트에서의 참조 권한은 readonly를 고려한다3. root 에그리거트끼리의 관계(행위)와 이 관계에 의존된 도메인들 관계,행위라고하면 아래 예시에서 Supplement에 해당한다. 관계를 매핑하는 entity (행위) -&gt; root쪽으로 방향을가지되, readonly 를 권장한다. insert/update 가 영속성으로 관리되면 안된다. service transaction으로 제어해야한다 4. MSA를 고려하자 추후 각 root 에그리거트들은 하나의module로서 하나의 appliation으로 동작할수있음을 유의하자 서로의 연관관계는 가능한 약결합으로 한다 도메인 나누기만약에 관계를 나타내는 도메인에도, 하위 도메인이 있다면? 네이밍 변경을고려. 공장에서 상점에 공급한다는 의미로 변경. MarketFactory -&gt; Supplement 완성된 에그리거트 영역 여담 - DDD에서 package 구조대부분의 spring 기반의 프로젝트는 아래와 같은 구조를 하고있을것 123456|-- controller |-- service |-- repository |-- model|-- config|-- Application.java 하지만 페키지 구조를 만드는 방법은 매우 다양 DDD의 레이어별로 나누는 방법123456|-- presentation |-- domain|-- order|-- member|-- application|-- infrastructure 그리고 도메인 내부에서 레이어를 나누는 방법도 있다 12345678910|-- order |-- presentation |-- domain |-- application |-- infrastructure|-- member |-- presentation |-- domain |-- application |-- infrastructure 무엇이 정답이다 라고 말할수는 없는것 같다도메인과 서비스의 크기에따라, 구성원들의 합의에 다라 달라질것이다. 제가 담당하는 서비스의 페키지구조는 아래와 같습니다123456789|-- order |-- controller |-- presentation |-- domain |-- application |-- repository|-- infrastructure|-- config|-- exception ( 참조 : https://stylishc.tistory.com/144 ) JPA 에서 단방향 관계 맺기 ★★★단방향과 양방향db에서의 연관관계란 (rdb 기준) join을위해서 테이블과 테이블이 key를 통해 참조하는것 양쪽에 공통적으로 가지고 있는 key가 존재, 2개 테이블의 데이터로만 본다면 방향성이 있을까? 결과적으로 데이터가 나왔을때도 방향이라는것이 정해져있지 않고, join기준에 따라서 쿼리가 바뀌며, 이에따라 기준이 바뀐다고 볼 수 있음. jpa에서 연관관계 DDD(객체지향)에서의 연관관계란 권한과 책임을 가진다. 권한 / 책임에 따라서 로직과 디자인에 영향을 준다. 방향성에따라 복잡도 및 side effect가 발생할 수 있다. 개발편의성모든 로직을 root 에그리거트를 기준으로 작성하는 경우 불편해질수 있습니다예를들면 Car에 대한 접근을 하려면 MarketRepository를 통해 Market에 대한 정보를 가지고온 다음 하위 도메인인 Department에게 Car 조회를 해달라고 위임합니다. Department는 Car의 정보를 Market에 전달하고 그 데이터를 활용합니다. 하위도메인에 대한 접근이 매우 잦아진다면 그 플로우가 복잡해 질 수 있습니다.그런경우 그 도메인을 root도메인으로 승격시키는것을 고려해볼수도 있습니다. 권한 양방향 관계를 가진다는것은 하위도메인에서 상위도메인의 데이터를 조회/변경을 할 수 있다는 의미이다. 그리고 변경을 하고나서 save가 이루어지는 경우 상위 도메인의 내용이 변경 될 수 있음을 의미한다 사실상 상위/하위 관계가 없어지는것과 같다고 생각한다. 이문서에서는 모든 관계는 단방향기준으로 공유드립니다기본적으로 양방향 관계는 가능한 지양하겠습니다. 1:1 - @OneToOne이번예제에서는 자식이 부모키와 동일한것을 사용하는경우, 자식이 부모키를 fk로 가지고있는 경우 2가지로 분류하어 서술합니다. parent1234567891011121314151617181920@Table(name = &quot;market&quot;)@Entity...public class Market { @Id private long marketId; //1. 자식이 부모키와 동일한것을 사용하는경우, @OneToOne(cascade = CascadeType.ALL) @PrimaryKeyJoinColumn private Address address; // or //2. 자식이 부모키를 fk로 가지고있는 경우 @OneToOne(cascade = CascadeType.ALL) @JoinColumn(name = &quot;market_id&quot;) private Address address; } child한쪽에서만 key를 소유하고있어서 단방향으로 관계를 맺음 1234567@Table(name = &quot;address&quot;)@Entity...public class Address { @Id private long marcketId; } or 12345678@Table(name = &quot;address&quot;)@Entity...public class Address { @Id private long addressId; private long marcketId;} N:1 &amp; 1:N - @ManyToOne &amp; @OneToMany1:N 관계에서는 N쪽에서(자식쪽) 부모의 key를 가집니다. parent1234567891011@Table(name = &quot;market&quot;)@Entity...public class Market { @Id private long marketId; @OneToMany(cascade = CascadeType.ALL) @JoinColumn(name = &quot;marketId&quot;) private Set&lt;Department&gt; departments} child1234567891011@Table(name = &quot;department&quot;)@Entity...public class Department { @Id private long departmentId; //자식은 부모의 key만 가지고있어서 접근불가! private long marketId; } 관계 annotation들(@OneToOne등)의 주요 options크게 2가지 종류의 annotation으로 데이터의 연관관계를 표현하게된다.도메인 객체로서의 관계를 먼저설명하고, / 이후 컬럼으로서의 관계에 대해 설명한다 도메인 객체로서의 관계를 정의하는 anotation으로는 @OneToOne, @ManyToOne … 것들이 있다. cascade1@OneToMany(cascade = CascadeType.ALL) 영속성을 의미한다 부모를 저장할때 자식도 같이저장, / 제할때 같이삭제 등등 영속성을 관리할때 사용한다 종류 ALL - 모두 PERSIST MERGE REMOVE REFRESH DETACH fetch1@ManyToOne(fetch = FetchType.LAZY) 데이터를 가지고올때 fetch하는 방식을 정의한다. 크게 LAZY / EAGER 가 있다 LAZY : 접근시도시 로딩 xxxToMany 의 디폴트 EAGER : 부모데이터 로드시 함깨 로드 xxxToOne 의 디폴트값 orphanRemoval (고아객체 허용/삭제여부)1@OneToMany(orphanRemoval = true) 관계에서 child 에서 참조하고있는 부모의 키 (fk)를 nulll로 셋팅하게되면 관계를 끊은것으로보고, 고아객체가된다 일반적인 케이스에서는 고아객체를 접근 할 수 없다(root 를 통해서만 접근하므로 ^^; 그렇게 되어야한다) orphanRemoval 이 true로 설정되어있다면 고아객체가 되는상황에서 child를 제거한다. optional1@OneToMany(optional=false) 관계를 가지는 도메인이 필수값인경우 optional을 false로 줄 수 있다.객체 생성시 해당 값이 null이면 exception이 난다 컬럼 annotation(@Column) 의 주요 options두번째로 @Column의 옵션이다.이항목은 사용하고있는 infrastructure 의 스팩과 닿아있다고 생각하면 편하다.사용하고있는 infrastructure의 해당 컬럼의 속성에따라 실제 만들어지는 쿼리도 달라지게된다. 1@Column(name = &quot;registerDatetime&quot;, nullable = false, updatable = false, insertable=false,unique=true, length=100) name: 테이블 컬럼이름 nullable : 해당 컬럼이 nullable인지 여부 unique : 해당 컬럼이 unique인지 여부 length : 해당 컬럼의 길이. string 인경우에만 사용하도록하자. default : 255","link":"/2021/06/15/ddd-jpa-1/"},{"title":"[javascript] 중복클릭 방지 - 세마포어 이용하기","text":"중복클릭 방지가 필요한 이유 중복된 클릭으로 인한 요청은 원하는대로 에플리케이션이 의도한대로 동작할수 없게 할 뿐 아니라 데이터의 정합성을 해칠 수 있음. 물론 이를 막기위해 backend는 중복된 요청이 오더라도 데이터의 정합성에 이상이 없더록 처리가 되어야함 front end 또한 중복된 요청이 가지않도록 인터페이스에서부터 막을 필요가 있음 중복 클릭 방지라는것은 경합상황에서 한번만 수행되도록 하는것! 예시대표적으로는 데이터를 등록하거나 수정하는 버튼이 있고, 이 이벤트가 연속으로 발생하는 경우이다.이때 사용자의 액션이나 네트워크 이슈등의 원인이 겹쳐서 중복으로 요청이 수행될 수 있다. javascript 에서 중복된 요청을 막는 방법을 알아보자. 일반적인 해결법 - flag일반적으로 아래처럼 flag를 두는 방법이있다.하지만 경합상황에서는 (특히 네트워크가 안좋은상황에서) 중복으로 doSomthing();이 실행되는 현상이 발생한다. 12345678910111213var isDisabled = false;$('#button').click(function () { if (isDisabled) { //&lt;-( 1 ) 수행가능여부 검사 alert(&quot;이미 작업이 수행중입니다.&quot;); return false; } else { isDisabled = true; //&lt;-( 2 ) 실행 불가능하도록 flag 변경 doSomthing(); isDisable = false; //(3)수행가능하도록 열어준다. settimeout을통해 X초 뒤에 풀어주는것도 방법이다. }}); 만약 (3)의 코드를 사용하지 않는다면 1회만 기능을 수행하도록 막게된다. (3) 에서 setTimeout() 을 사용하면 일정시간 후에 풀어주도록 구현할수있다. Semaphore로 중복 방지하기세마포어를 활용한다. 운영체제에서도 사용하는 방법이다.동시에 접근하더라도 작업 수행여부를 판별하기전에 횟수를 제한한다.1로 설정을 하면 2회이상 동시에 접근이 되는것을 막을 수 있다.flag와 다른점은 횟수를 다르게 설정할수 있다는 점이다. 작업이 끝난 후 다시 접근이 가능하게 하려면 count를 증가시켜준다.위에서 언급하였드시 카운트를 복구하지 않으면 총 사용횟수만 제어할 수 있고, 일정시간 후에 회복 시키는것도 가능하다. 12345678910111213141516var acceessableCount = 1; //동시접근제한수, 리소스에따라 변경가능$('#button').click(function () { acceessableCount = acceessableCount -1; //count부터 뺀다 if (acceessableCount &lt;= 0 ) { alert(&quot;이미 작업이 수행중입니다.&quot;); } else { doSomthing(); } acceessableCount = acceessableCount +1; //작업이 끝난 후 다시 작업할수 있게하려면 +1을 한다. 회복시키지 않으면 코드제거.}); 세마포어 관련글 : https://namu.wiki/w/세마포어","link":"/2020/02/27/double-click-problem-javascript/"},{"title":"프로그래밍에서 예외 - 기초 개념","text":"예외란?프로그램의 동작이 정상적인 처리 범주에서 벗어난 경우 “ 예외(Exception)가 발생했다.” 라고 말한다. 예상하지 못한 사건의 발생이라고 볼 수 있다. 예외는 언제 발생하고 우리는 어떤 마음가짐으로 대해야할까? 일반적으로 프로그램을 구현할때는 목적과 실행범위가 있다.아래 플로우차트를 살펴보자 매우 간단해보이지만 구현에 들어가게되면 고려할 사항이 많아진다.올바른 유저인지판단, 눈이온다면?, 기상청api연동실패, 지각인지 확인하기, 출퇴근기록하기…보여지는 내용보다도 훨신 다양한 경우의 수를 맞이하게된다. true/false 2개로 이루어진 선택지가 10개만 되더라도 2^10 인 1000개이상 경우의 수가 나오고, 이 모든경우에 대응할수 있어야한다.그리고 구현하는 개발자가 이같은 모든 상황에 대응할수는 없기때문에 예외가 발생하게된다. 물론 system이 처리 할수없는경우에서도 발생한다. out of memory, thread full 같은 경우이다. 예외의 발생예외는 매우 다양하게 발생한다.대표적으로 필요한 데이터가 없을때 발생한다.예외가 발생했을때 대응이 가능한 경우도 있는반면 대응을 할 수 없는 경우도 있다.아래 예시를 통해 살펴보자 NullPointException(NPE)대표적인 Exception인 NullPointException(NPE) 을 살펴보자12User user = null;user.goToOffice() // NPE위경우라면 null 여부를 체크하여 대응을 할수도 있지만, 그렇게 하지 않은 경우 예외가 발생한다. 외부연동외부 데이터를 연동하기위해 api를 호출했다가 Timeout 이발생하는 경우도 생길 수 있다.이런 경우는 내가 만든 application에서는 미리 대비할수 없다.결과에 따라서 대응할수 있는 방법만 있다.상황에 따라서 다르겠지만 선택지는 있다. 기본값을 적용하여 처리 처리할수 없으니 기능 수행 불가 동작중지 (쇼핑몰 물건 구입시 이용시 카드이용불가) 이 동작을 생략할수 있다면 건너뛰기 (쇼핑몰 물건 구입시 - 로깅, 문자보내기- 상대적으로 덜중요) 예외가 발생하면?개발자는 소프트웨어를 만든다.가장 중요한것은 의도한대로 동작하는 프로그램고, 그다음이 좋은 프로그램을 만드는 것이다. 예외처리는 이 둘의 중간정도 영역이라고 생각한다.오류로인해 데이터의 정합성이 꼬여서 복구하기가 매우 힘든 상황이 되어 동작하지 않는 프로그램이 될 수 있다.사용자에게 “네트워크 오류입니다 다시 시도해주세요” 라는 문구를 보여주는것 대신에 “time out exception ….” 같은 문구가 노출되어 프로그램의 신뢰성이 낮아지기도한다. 안정적인 프로그램을 만드는것은 개발자의 필수적인 역량이다. 예외에 대한 대처예외가발생했다면 오류인지 확인하는것이 필요하다.모든 예외가 오류는 아니다. 하지만 오류가 있다면 예외를 통해서 알 수 있다. 오류의 수정처음부터 완벽한 프로그램을 만들 수 있으면 좋지만… 이는 거의 불가능하다.예외가 발생했다는 뜻은, 프로그램이 의도하지 않는 동작을 했다는 의미가된다. 처리가 불가능하여 의도적으로 예외로 처리한경우도 있을것이다.경우에 따라서는 취약점을 유발 할 수도 있기때문에 원인을 파악하고, 보완하도록 하자.그렇게 하기 위해선 오류의 탐지가 매우 중요하다. 오류의 탐지아래 사항들이 준비되어있다면 좋다. 운영중인 서비스라면 - 오류가 났을때 알람을 빠른시간내에 받을수 있도록 한다. (문자,메일,메신저 등) 오류의 등급은? - application전체장에, 일부기능장애, 장애아님 .. 왜 발생했는지 ? 소스코드의 어느부분에서 발생했는지? 대응오류의 심각한정도와 시간적 여유에 따라 대응은 달라진다 오류가 없는것이 확인된 이전버전으로 롤백 눈에 보이는 증상을 해결하도록 방어코드 추가 원인을 파악하여 수정 관련포스트프로그래밍에서 예외 - 기초 개념java에서 exceptionwep api 서비스 application에서 exception","link":"/2020/10/11/exception-1/"},{"title":"java에서 exception","text":"주로 문법과 활용방법에관해 다루는 포스트이다. try-catch-final throw, throws checked, unchecked exception custom exception 관련 포스트프로그래밍에서 예외 - 기초 개념java에서 exceptionwep api 서비스 application에서 exception try-catch-final예외가 발생할 가능성이 있다면 이 부분에 대하여 처리할수있다. 1234567891011try { doSomething();} catch (CustomException e){ log.warn(); //do nothing} catch (NullPointException e){ log.error(); rollback();} final{ close();} try 를 수행하다가 오류가나면 catch 가 처리하고,try나 catch가 끝나면, final 이 수행된다. trt에서 발생하는 예외 종류에 따라 처리 방법을 다르게 할 수 있어서, 하나의 try블럭에 여러개 catch가 대응할수 있다. 처리방법으로는 상황에 따라 크게 다르다. 로그를 남긴다 데이터를 원상복구한다 예외를 던진다 … throw/ throws얼핏보면 비슷해보이지만 성격이 완전히 다른 친구들이다. (overloading vs overriding이 연상된다.) throwthrow 는 예외를 던진다 는 표현이 정말 잘 어울린다. 개발자의 판단으로 예외를 발생시킨다. 함수를 작성한다고 가정하자. 일반적으로 함수는 인풋을 받아 처리하여 아웃풋을 준다.하지만 이 함수를 호출하는 다른 함수(caller)들은 내부를 모르고 사용하기때문에 원치 않는 상황이 생길 수 있다. 원하는 인풋의 형태가 아닌경우 (숫자를 원했지만, 특수문자가 들어옴) 원하는 인풋의 범위가 아닌경우 (양수만 취급하는데 -1이 들어옴) 원하는 시간내에 처리되지않는경우 (2초이내에 처리되지않으면 예외로처리하겠다!) … 아래는 나눗샘을 하는 함수의 예시이다. 0으로 나누는경우 RuntimeException을 명시적으로 던지도록 하였다.123456public double divide(double target, double denominator) { if (denominator == 0) { throw new RuntimeException(); } return target/denominator;} throwsthrows는 성격이 다르다. 예외가 발생했을때의 처리를 호출자에게 위임한다. 12345678// &quot;1&quot;이라는 문자를 숫자1로 바꿔주는 함수int parseOne(String s) throws ParseException { if (&quot;1&quot;.equals(s)) { return 1; } else { throw new ParseException(s, 1); }} throws ParseException를 적어주었다면, 해당 함수에서 ParseException가 발생한다면 예외로 인해 application이 동작을 멈추지않는다.(당장은) 호출한 caller는 예외발생을 전달받으며, try-catch를 통해 아무일도 없었다는듯이 이후 로직을 진행할수도 있다. 그대로 예외를 던져버리거나 자신이 만든 Exception으로 래핑할수도있다. callee와 마찬가지로 caller에게 위임할수도 있다. throws의 과도한사용은 예외에 대한 책임소재가 불분명해지고, 트래킹도 힘들기때문에 추천하지않는다.일반적으로 util 성격을 띄는 모듈에서 자주사용하고, 이 util사용시 오류핸들링을 caller에게 위임한다. checked exception / unchecked exception checked exception과 unchecked exception의 차이점은 예외의 처리를 강제하는가?이다. checked exception예외처리를 강제한다. try-catch를 통해 예외가 발생했을때의 상황에대해 처리리를 해주어야한다. 해당 메서드에서 처리하지 않으려면 throws를 통해 상위 메서드에 책임을 위임 할 수 있다. 하위메서드에서 throws를 한다면 caller인 상위 메서드에서 책임을 가진다. 마찬가지로 throws를 통해 더 상위의 메서드에게 위임할수있다. 하지만 상위메서드에 위임하는 상위메서드의 책임을 가중시키고 책임소제가 명확해지지 않는 등 단점이 많기때문에 추천하지 않는다. 대표적으로 IOException 이 있다. unchecked exception예외 처리를 강제하지 않는다. runtime exception을 상속한다. 처리를 강요하지 않지만 try-catch로 감싸 처리를 해도 상관없다. 대표적으로 null point exception이 있다. custom exception - 자신만의 예외unchecked exception기준으로는 RuntimeException만 상속받는다면 기본적인 준비는 끝이다.필요하다면 예외에 사용할 다른 정보들을 추가로 받을 수 있게 한다.응답 코드 메시지를 아래처럼 enum 으로 관리한다고 가정한다면, 12345678910public enum ResponseCode { SUCCESS(0, &quot;성공&quot;), NOT_EXIST(1001, &quot;존재하지 않음&quot;), INVALID_STATE(1004, &quot;올바르지 않은 상태&quot;), UNKNOWN(-1, &quot;알 수 없는 오류&quot;); ... private final int code; private final String message;} ResponseCode를 통해서 생성하도록 할 수 있다. 123456789public class CustomException extends RuntimeException { private int code; pirvate String message; CustomException(ResponseCode responseCode){ this.code = responseCode.getCode(); this.message = responseCode.getMessage(); }}","link":"/2020/10/11/exception-2/"},{"title":"web api 서비스 application에서 예외 (오류와 거절)","text":"외부에 제공하는 api오픈 api처럼 외부에 api를 제공하고, api 명세서 제공한다.이경우 api의 스팩이 정해져있고 다양한 clientem들이 이 규칙에 따라서 호출하게된다.api는 성공하는경우가 대부분이겠지만 상황에 따라서 실패하기도 하고 이에따라 실패 메시지를 받게된다.실패에도 다양한 경우가 있다. 이포스트는 여러가지 실패한 상황과 예외에 대해 다뤄보려고한다 관련포스트프로그래밍에서 예외 - 기초 개념java에서 exceptionwep api 서비스 application에서 exception 예시아래는 카카오-친구에게보내기 api의 예시이다.https://developers.kakao.com/docs/latest/ko/message/rest-api#send-friend HTTP/1.1 200 OK 12345678{ &quot;successful_receiver_uuids&quot;: [&quot;abcdefg0001&quot;,&quot;abcdefg0002&quot;], &quot;failure_info&quot;:[{ &quot;code&quot;: -532, &quot;msg&quot;: &quot;daily message limit per sender has been exceeded.&quot;, &quot;receiver_uuids&quot;: [&quot;abcdefg0003&quot;] }]} 일반적으로 응답코드와 메시지가 포함되어 response를 전달하게된다.이처럼 실패한경우에도 코드와 메시지를통해 구분가능하다.이 api를 사용하는 클라이언트들이 있고, 코드와 메시지가 정해져있다면 변경하기 쉽지않다. 정해진 응답값응답값은 클라이언트와의 약속이다. 한번 정해지면 바꾸기 쉽지 않다.이렇게 변하지 않는값으로 간주된다면 enum을 통해서 관리하는것도 방법이다. 12345678910public enum ResponseCode { SUCCESS(0, &quot;성공&quot;), NOT_EXIST(1001, &quot;존재하지 않음&quot;), INVALID_STATE(1004, &quot;올바르지 않은 상태&quot;), UNKNOWN(-1, &quot;알 수 없는 오류&quot;); ... private final int code; private final String message;} 실패 vs 거절 vs 예외성공 응답이 아닌 다른 값들이 전달되었다면 이것은 오류라고 볼 수 있을까?성공 응답값을 주지 못하는 상황에서 어떠한 대처가 되어있는지에 따라서 거절인지 예외인지 다르게 부를 수 있을것이다. 예시id를 input으로 받아 이름을 output으로 받는 api가 있다고 가정해보자.1234567891011121314151617@GetMapping(/)public Response&lt;String&gt; getUserName(String userId){ User user = getUser(); if(user == null){ return Response.builder() .code(ResponseCode.NOT_EXIST.getCode()) .message(ResponseCode.NOT_EXIST.getMessage()) .build(); } return Response.builder() .code(ResponseCode.SUCESS.getCode()) .message(ResponseCode.SUCESS.getMessage()) .data(user.getName()); .build();} 요청이 올바르지 않거나, 원하는 데이터가 없을경우에도 요청한 client에게는 HTTP STATUS 200 OK 가 내려가며 이는 정상 응답값이다.위 예시에 있는 NOT_EXIST(1001, &quot;존재하지 않음&quot;) 는 이미 유저가 없는 경우를 예상한 플로우라고 볼 수 있다. application상의 로직으로 구현되어 정상적인 분기처리후 해당 응답이 내려가게된다. 실패 의 이유는 다양할수 있으나 거절 은 로직으로 판단하여 수행된 application의 정상로직이다. 실패실패의 원인은 다양하다. 성공하지 못하면 모두 실패이다.위 사례처럼 정당한 사유로 거절된 경우도 있을것이다. 하지만 모든 상황을 예상할수는 없다.원치 않는 상황이 발생하여 각종 예외(Exception)가 발생할 수 있고, 이를 재대로 대처하지 못했다면 오류가 되어500 internal server error 가 발생하게된다. 예외예외(Exception)는 java 언어에서 사용할수있는 구현 수단이다. 이를 잘 활용하고 대응하여 거절 로 응답을 내려 줄 수 있다. 예외를 잘 관리하지 못한다면 오류가되어 원하지 않은 응답이 내려가게 될것이다. 직접 예외를 만들고 이를 핸들링하여 예외를 활용하여 거절응답을 하도록 구현 하는 방법도 많이 사용한다. 분기와 예외거절 응답을 내려주기위해서 분기처리를 해도 되지만, try-catch 또는 exception handler 를 활용한 방법도 있을것이다. 분기처리는 if-else 구문으로 정해진상황을 파악하여 거절응답을 내려주는 방법이다.본 포스트에서는 분기보다는 예외에 초점을 맞추어 설명한다. 예외를 활용하는 가장 큰 이유는 @Transactional 이다. 수행중인 서비스가 데이터의 변경을 가지고오지않는다면 정해진 거절응답만 하면 해당 요청에 대한 응답은 마친샘이다. 비교예시아래의 예시 경우라면 0으로 나누기전 3개의 데이터는 repository에 저장될수있다. 일관성을위해 데이터가 저장되면 안되는 상황이라면 rollback시킬 필요가있다. 12345678//use exception@Transactionalpublic divideAndSave (Integer value, List&lt;Integer&gt; datas){ // value = 6, datas = [1,2,3,0] for(Integer data : Datas){ repository.save(value / data); // 6/0 에서 DivideByZeroException }} try-catch 라면 @Transactional 의도움을 받아 transaction이 실행되기 전으로 되돌려 저장되지 않도록 할수있다. 1234567891011121314//use if-else@Transactionalpublic divideAndSave (Integer value, List&lt;Integer&gt; datas){ List&lt;Integer&gt; keys = new ArrayList(); // value = 6, datas = [1,2,3,0] for(Integer data : Datas){ if(data == 0){ repository.removeAll(keys); } int key = repository.save(value / data); // 6/0 에서 DivideByZeroException keys.add(key); }} if-else 구문이라면 저장된 데이터의 key를 기억했다가 이를 모두 제거해야하지만 주의사항단, try-catch를 사용한다면 주의해야한다.AException이 발생하여 A영역의 catch에 들어가게되면 데이터는 rollback되지않는다.catch에 해당하는 로직만 수행된다.BException의경우 내부에서 한번더 예외를 발생시켜 transactional에 의한 rollback기능이 수행된다 1234567891011121314151617//use exception@Transactionalpublic divideAndSave (Integer value, List&lt;Integer&gt; datas){ // value = 6, datas = [1,2,3,0] try{ for(Integer data : Datas){ repository.save(value / data); // 6/0 에서 DivideByZeroException } } catch (AException e){ //A log.error(&quot;...&quot;); } catch (BException e){ //B log.error(&quot;...&quot;); throw e; } } 결론 발생할수 있는 상황을 가능한 고려하여 오류가아닌 거절이 되도록 해야한다. 거절을하는 과정에서 구현상 분기를 사용해도되고 CustomException를 활용할 수 있다. custom exception 과 예상치못한 진짜 exception을 구분하여 발견/수정할수 있어야한다 외부에서는 내부구현을 알 수 없다. 어떠한 상황이던 client에서 적절한 응답을 받을 수 있게 대응하자.","link":"/2020/10/11/exception-3/"},{"title":"[blog] hexo로 github page 블로그 만들기","text":"블로그 여기저기 플렛폼을 옮겨다니기도하고, 삽질도하다보니 블로그를 만드는 나만의 방법을 공유하고자 포스팅을 하게 되었습니다. 다양한 사람들이 각자의 목적을 가지고 블로그를 만든다.이 블로그는 평소에 경험하거나 공부했던내용을 복습, 정리, 공유하기위해서 만들었다. 블로그는 네이버블로그, 티스토리와같은 블로그 기능을 사용할수있는 다양한 플랫폼들이 있지만 그중에서 github page 를 통해 블로그를 만드는 방법을 알아보자 블로그 만들기 시리즈는 계속 포스팅 될 예정이다 hexo로 블로그만들기 테마 연동하기 포스팅 하기 - (with admin) gitpage란 https://pages.github.com/ github 에서 repository만 만든다면 자동으로 홈페이지를 만들어 주는 github의 서비스중 하나이다. 개설이 매우 쉽고 자유도도 높아 개발자들이 이 방법을 많이 선택한다. github 계정 생성 - https://github.com/ github repositort생성 이때 repository의 이름은 계정명.github.io로 한다.이 블로그의 경우에는 hyeonguj.github.io라는 이름이 된다.그리고 이곳은 홈페이지의 내용이 올라갈 저장소가 된다. hexogitpage로 repository만 생성해도 블로그 웹 페이지는 할당이 된다. 하지만 다른 블로그들처럼 내프로필을 올리고, 글을쓰고, 내가 원하는대로 테마를 변경할수는 없다. 이런것들을 지원해주는 도구로는 가장 유명함 jekyll가 있다. 이번 포스트에서는 또 다른 도구인 hexo를 이용한 방법을 알아보려한다. (https://hexo.io/)공식홈페이지의 소개에 따르면 simple,fast,powerful blog framework 이다. 설치hexo를 설치하기위해서는 2가지를 먼저 설치해주어야한다.각각 아래에서 설치해주도록 하자 nodejs (https://nodejs.org/) git (https://git-scm.com/) 설치가 잘되었다면 단순히 아래 명령어를 실행시키기만 하면 블로그를 작성할 초기화작업이 끝난다.먼저 원하는 폴더로 이동후 아래명령어를 실행시켜주도록하자12npm install hexo-cli -ghexo init명령어 실행후 아래와 폴더안에 아래와같은 파일과 폴더들이 생성된것을 볼 수 있다.1_config.yml node_modules package-lock.json package.json scaffolds source themes 각 파일/폴더의 역할 _config.yml : 블로그의 각종 설정값. 이름, 저자등… package-lock.json / package.json : 각종 라이브러리나 플러그인의 버전정보, node_modules : 다운로드된 라이브러리들 source : 작성한 post, 이미지 등 원본 파일들 themes : 블로그의 테마 실행해보기이곳은 블로그의 이름, 테마, 플러그인, 작성한 포스트 원본파일을 관리하는 최상위 폴더이다이곳에서 hexo server 명령어를 실행해보자실제로는 블로그에 반영되어있지 않지만 자신의 pc에서 실행시켜볼수 있는 기능을 사용 할 수 있다. 1234hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 그리고 웹브라우저에서 위 주소로 접속하게되면 아래와같은 hexo에서 만들어놓은 기본 화면을 볼 수 있다","link":"/2020/02/09/how-to-make-gitpage-with-hexo-1/"},{"title":"intellij 에서 method chain이 길때 type hint 보는 방법 (show method chain hints)","text":"show method chain hints 함수형 프로그래밍을 사용하게되는만큼 method chain이 자주등장하게 된다.익숙하지 않거나, 길어져서 보기힘들다면 intellij의 도움을 받아보는건 어떨까? 방법우선 intellij 2019.02 버전 부터 사용하능하다는점을 알아두자.(2018년 7월 25일 업데이트버전) 방법은 간단하다. find action 창을 연다 (윈도우 기준 ctrl+shift+a) show method chain hints 를 검색한다 기능을 활성화 한다 힌트가 달린것을 확인한다 한계intellij 소개 문서를 보면 알수 있드시 기능의 이름은 “Type hints for long method chains” 이다.짧으면 힌트는 사라진다.짧다/길다를 가르는 기준은 4줄이다. (같은 기능의 코드라도 3줄이되면 사라진다..) 기타힌트를 우클릭하여 개별적으로 끄는것도 가능하다. 출처https://www.jetbrains.com/idea/whatsnew/#v2018-2-java","link":"/2019/01/31/intellij-%EC%97%90%EC%84%9C-method-chain%EC%9D%B4-%EA%B8%B8%EB%95%8C-type-hint-%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95-1/"},{"title":"Intellij 느릴때  - 메모리 할당량 늘리는법 (2020.2 업데이트버전)","text":"2020.2 버전에 Memory 할당량을 변경하는 새로운 방법이 추가되었고, Memory Indicator 표시하는 방법이 조금씩 변경되었다. 본 포스트는 이전에 작성한 Intellij 느릴때 - 메모리 할당량 늘리는법 포스트를 intelliJ 2020.2버전에 적용하는방법입니다 memory 할당량 변경사용자들의 요구가 많았는지 이전버전버전보다 더 눈에 띄는곳에 자리한다.위치는 Help &gt; Change Memory Setting 이다. 클릭하면 아래와같은 창이 나오게되고 자신의 pc성능에 맞게 조절하도록한다.필자의경우 16G 메모리를 사용하고있으며 4G(4096)으로 셋팅했다. memory indecator변경된 Memory 할당량은 오른쪽 아래 memory indicator에서 확인할수 있다.Memory Indicator를 활성화 시키는 방법 역시 2020.2 버전에서 변경되었다. 우측하단 status bar 를 우클릭 Memory Indecator 체크","link":"/2020/08/11/intellilj-memory-allocation/"},{"title":"[java] enum 활용법 - 알아두면 좋은 TIP","text":"서론type이나 상태값을 나타내기위해 많은분들이 enum을 사용합니다.enum을 활용하는 방법, 사용할때 알아두면 좋은 팁들을 정리해보려합니다. 예제아래는 설명을 위해 사용할 예제입니다. 본문에 계속 사용될 예정입니다.주문의 상태를 나타내는 enum입니다. 1234567891011121314public enum OrderStatus { ORDER(&quot;주문&quot;), PAYMENT(&quot;결제완료&quot;), DELIVERY(&quot;배송&quot;), REJECT(&quot;거절&quot;), REFUNDED(&quot;환불&quot;), CANCEL(&quot;취소&quot;); private String description; TicketStatus(String description) { this.description = description; }} enum 기본기능 활용name()name() 를 통해 이름을 찾을 수 있습니다이름을 따로 맴버변수로 등록할 필요가 없습니다. 12String name = OrderStatus.DELIVERY.name();log.debug(&quot;name : {}&quot;, name); output :1name : DELIVERY values()Enum들을 모두 포함하고있는 배열을 얻을 수 있는 방법도 있습니다.1OrderStatus[] values = OrderStatus.values();Java Collection의 List로 사용하고자 하신다면 Arrays.asList()를 사용하시면 됩니다.stream등 collection의 기능을 활용하기 편리해집니다.1List&lt;OrderStatus&gt; orderStatuses = Arrays.asList(OrderStatus.values()); find by nameString으로 enum값을 찾는경우입니다.String으로 된 변수에 이름이 들어가있고. 이 이름으로 enum값을 찾아야하는 경우가 있습니다.이럴때는 매우 다양한 방법으로 구현할수 있는데요. valueOf()대표적으로는 enum의 기본기능을 활용하는 방법입니다.valueOf()는 String으로 enum값을 찾아주는 대표적인 방법입니다. 12345678public static OrderStatus trycatchValueOf(String name) try { return OrderStatus.valueOf(name); } catch (Exception ex) { log.warn(&quot;Exception Thrown&quot;, ex); return null; }} NullPointerException 가발생하거나, 의도하지 않은 문자열인경우에 IllegalArgumentException이 발생하므로 try-catch구문이 필요합니다. try-catch을 로직의 플로우로 사용하는것은 지양하기때문에 이방법을 추천드리지는 않습니다. iterator 사용또한 valueOf()의 경우 내부적으로 iterator를 사용하기때문에 모든항목을 하나씩 비교합니다. 때문에 O(n)의 시간복잡도를 가진다는 단점이 있습니다. 12345678public static OrderStatus iterationFindByName(String name) { for (OrderStatus status : OrderStatus.values()) { if (name.equals(status.name())) { return status; } } return null;} 시간복잡도를 줄이기위해서는 static HashMap을 미리 구성해놓는 대안이 있습니다. [Guava] Enums.getIfPresent()Google 에서만든 Guava 라이브러리는 우리가 원하는 기능을 완벽하게 지원하는데요아래와같이 사용 할 수 있습니다123public static OrderStatus getIfPresent(String name) { return Enums.getIfPresent(OrderStatus.class, name).orNull();} Json아무런 설정을 하지않는다면 JsonFormat.Sahpe.String 으로 설정되어 되어있다면 아래와같이 출력되는데요.123{ orderStatus : CANCEL} api의 response를 통해 전송할때 json으로 변환하는경우가 습니다. description등 enum의 맴버변수까지 접근하길 원한다면 object형태로 전송할수 있습니다. 123456789101112@JsonFormat(shape = JsonFormat.Shape.OBJECT)...public enum OrderStatus { ORDER(&quot;주문&quot;), PAYMENT(&quot;결제완료&quot;), ...; private String description; public String getDescription(){ return this.description; }} output :12345{ orderStatus : { description : '취소' }} enum의 name까지 필요한경우는 getter를 만들어줍니다.JsonFormat.Shape.OBJECT에서 OBJECT를 만드는 기준은 getter입니다.12345678910111213141516@JsonFormat(shape = JsonFormat.Shape.OBJECT)public enum OrderStatus { ORDER(&quot;주문&quot;), PAYMENT(&quot;결제완료&quot;), ...; private String description; public String getDescription(){ return this.description; } String getName() { return this.name(); }} output :123456{ orderStatus : { name: 'CANCEL' description : '취소' }} 비교equals() 로 비교할 필요 없이 == 로 비교하면 정상적으로 비교될 뿐 아니라 더 효율적입니다.enum 은 singleton으로 생성되기때문에 어느곳에서 비교하더라도 값이 동등 할 뿐 아니라 동일하게 취급되기 때문입니다. 변수로 람다 지정하기enum값에 따라 처리방법이 다르기때문에 분기처리하여 작업하는 경우가 자주 일어납니다.경우에 따라서는 enum에서 달라지는 행동의 스팩을 정의하는 역할을 한다면 어떨까요?enum의 값 하나하나마다 기능(함수나, 람다)를 담아두고 이를 호출하도록 합니다. 아래는 그 예시입니다.예시는 이해를 돕기위해 사칙연산으로 준비했습니다. 123456789101112131415161718192021222324252627282930313233343536enum Operation implements DoubleBinaryOperator { PLUS(&quot;+&quot;) { @Override public double applyAsDouble(final double left, final double right) { return left + right; } }, MINUS(&quot;-&quot;) { @Override public double applyAsDouble(final double left, final double right) { return left - right; } }, MULTIPLY(&quot;*&quot;) { @Override public double applyAsDouble(final double left, final double right) { return left * right; } }, DIVIDE(&quot;/&quot;) { @Override public double applyAsDouble(final double left, final double right) { return left / right; } }; private final String symbol; private Operation(final String symbol) { this.symbol = symbol; } public String getSymbol() { return symbol; }} 람다를 쓴다면 가독성을 훨신 좋게 만들 수 있습니다. 1234567891011121314151617181920212223enum Operation implements DoubleBinaryOperator { PLUS (&quot;+&quot;, (l, r) -&gt; l + r), MINUS (&quot;-&quot;, (l, r) -&gt; l - r), MULTIPLY(&quot;*&quot;, (l, r) -&gt; l * r), DIVIDE (&quot;/&quot;, (l, r) -&gt; l / r); private final String symbol; private final DoubleBinaryOperator binaryOperator; private Operation(final String symbol, final DoubleBinaryOperator binaryOperator) { this.symbol = symbol; this.binaryOperator = binaryOperator; } public String getSymbol() { return symbol; } @Override public double applyAsDouble(final double left, final double right) { return binaryOperator.applyAsDouble(left, right); }} 분류특정 주문이 취소 가능한지 체크하는 로직이 있다고 가정해 봅시다.enum으로 선언된 type으로 구별하려면 아래와 같이 할 수 있습니다. 1234567891011121314public enum OrderStatus { ORDER(&quot;주문&quot;), PAYMENT(&quot;결제완료&quot;), DELIVERY(&quot;배송&quot;), REJECT(&quot;거절&quot;), REFUNDED(&quot;환불&quot;), CANCEL(&quot;취소&quot;); public static final List&lt;OrderStatus&gt; CANCELABLE_STATUS = Arrays.asList(ORDER,PAYMENT); public static boolean isCancelableStatus(OrderStatus status){ return CANCELABLE_STATUS.contains(status); }} 참고자료https://stackoverflow.com/questions/23361418/lambdas-in-the-classical-operation-enum-examplehttps://www.javacodex.com/ENUMs/Calculator-using-enums-for-operations","link":"/2020/02/27/java-enum-usage-example/"},{"title":"interface 란? spring interface injection - interface의 구현체 주입","text":"동기 인터페이스(interface)는 자바 프로그래밍 언어에서 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상형이다. 위키백과 데이터를 가지고오는 repository가 있다고 가정해보자. 이 repository의 기능을 호출하여 원하는 데이터를 가지오고, 원하는 기능을 구현 할 수 있다. 그리고 실제로 데이터를 가지고 오는 방법에는 여러가지가 있다. mybatis, hibernate 처럼 방법이 다를수도있고 mydql, oricale, mongodb 처럼 저장소가 다를 수 있다. 하지만 이를 사용하는 caller입장에서는 원래 목적대로 데이터만 가지고 올 수 있으면 된다. 동일하게 여러가지 방법과 저장소를 repository라는 이름으로 부르고 그 역할을 데이터를 가지고 오도록 한다. 그리고 이를 호출하는 caller는 repository가 내부적으로 어떻게 동작하는지 구현체에 정보는 알 필요가 없다 이처럼 공통적인 기능을 interface로 정의하여 사용하는 입장에서는 동일하게.그리고 세부적인 내용과 다른점은 구현체마다 각자 구현을 책임을지고 이를통해 결합도도 낮추고 확장성을 높일수 있다. 그리고 인터페이스의 스팩에 맞게 여러 구현체를 만들어 두었을때, 사용하는 caller 입장에서는 적절한 인터페이스를 골라서 사용할 필요가 있다. 본문에서는 인터페이스를 선택하는 방법에 관하여 다룬다. 인터페이스의 사용같은 기능을 하는 여러개 구현체를 만들어놓고, 필요에따라서 구현체를 바꿔끼워가며 사용한다.사용하는 입장에서는 내부 구현을 알 필요는 없고 상황에 맞게 구현체를 선택 하여 사용 할 수 있다.그리고 실제 수행해야하는 동작들은 구현체가 책임을 가진다. 그렇다면 실제 로직에서 구현체를 선택하는 방법은 무엇이 있을까? spirng이 아닌 순수 java에서제일 많이 사용하는 예는 collection이 있다.1List&lt;String&gt; names = new ArrayList&lt;&gt;();우리는 names 가 ArrayList로 되어있는지 LinkedList로 되어있는지 알 필요없이 List로서 정의된 인터페이스를 사용하고, 실제 동작 로직은 구현체가 책임진다. spring - interface 주입받기어떠한 데이터를 가지고오는 방법으로 여러 종류의 datasource를 사용한다고 가정해보자.데이터를 가지고온다는 행위를 repository의 기능으로 하고 인터페이스를만든다그리고 이 방법에 대해서 구현체로 구현한다. interface 구현아래는 판매자 정보에 대한 인터페이스 예제이다123interface ShopRepository { ...} 그리고 각각 jdbc / hibernate 2개종류의 구현체가 있다1234@Repositorypublic class jdbcShopRepository implements ShopRepository { ...} 1234@Repositorypublic class HibernateShopRepository implements ShopRepository { ...} 사용이름으로 구분사용하는곳에서 이름으로 구분하는 방법이 있다. spring 에서는 인터페이스의 구현체가 여러개인경우 이름에 해당하는 의존성이 있다면 주입해준다12345@Autowiredprivate ShopRepository jdbcShopRepository;@Autowiredprivate ShopRepository HibernateShopRepository; 동일한이름이라면 @Primary12@Autowiredprivate ShopRepository shopRepository; 구현체를 구현할때 우선순위를 정해 줄 수 있다12345@Primary@Repositorypublic class jdbcShopRepository implements ShopRepository { ...} 1234@Repositorypublic class HibernateShopRepository implements ShopRepository { ...} @Qualifier변수명을통해 구현체의 이름으로 주입하기 싫다면 @Qualifier를 사용할수도 있다1234567@Autowired@Qualifier(&quot;JdbcShopRepository&quot;)private ShopRepository shopRepository1; @Autowired@Qualifier(&quot;HibernateShopRepository&quot;)private ShopRepository shopRepository2; nextapi를 호출하는 파라메터에따라서, 특정시기에따라서 등 여러가지이유로 동적으로 구현체를 선택해야 하는 경우가 있다.다음 포스팅에서는 동적으로 구현체를 선택하는 방법을 알아본다. https://hyeonguj.github.io/2020/02/07/spring-interface-choice-implements-dynamically/","link":"/2020/02/07/java-interface-1/"},{"title":"VisualVM:: jvm 모니터링 도구 (java 모니터링)","text":"동기대용량 엑셀파일 다운로드로기능으로 인해 OOM이발생. 이를 방지하기위한 대책마련을위해조사개발에 들어가기전에, 개발한것이 효과가 있는지 로컬에서 테스트 해보려고함 도구 이름 : VisualVM 현재 버전 : 1.4.2 다운로드 : https://visualvm.github.io/download.html 시작하기 : https://visualvm.github.io/gettingstarted.html 시작하기 (windows 기준입니다) 다운로드한다. 압축을푼다. 적당한 위치에 옮긴다 cmd를 통해 실행한다 jdk 위치를 미리파악해둔다 설정 등 유저데이터 저장할곳을 미리 선정해둔다 1visualvm.exe --jdkhome &quot;${jdkPath}&quot; --userdir &quot;${userPath}&quot; 실제예시1C:\\visualvm_142\\bin\\visualvm.exe --jdkhome &quot;D:\\APPS\\jdk&quot; --userdir &quot;C:\\Temp\\visualvm_userdir&quot; 실행확인 사용하기 intellij 등 ide에서 테스트하고자 하는 application 실행 원하는 항목 선택해서 확인하기 GC실제로 사용중인 메모리 영역은 GC가 되지 않는다.실험 전 GC를 실행하여 초기화를 해놓고, 실행중에도 GC를 수행하여 특정시점에 실제로 사용하는 메모리가 얼마인지 확인하도록 하자.","link":"/2019/02/01/java-%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%82%AC%EC%9A%A9%EB%9F%89-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81%EB%8F%84%EA%B5%AC-VisualVM/"},{"title":"jenkins 빌드시 git branch 충돌현상 방지하기","text":"jenkins 빌드시에 가끔 git branch 가 충돌이 나기도한다예를들면,예전에 받아두었던 브랜치(feature/a)이번에 빌드할 브랜치(feature/a/a/a) 로 되어있으면 feature/a 는 directory 로 쓸수없으니 충돌이 나게된다 쉽게 생각할수 있는 방법은 빌드할 브랜치이름을 바꾸거나jenkins서버에가서 branch들을 정리하는 방법이 일반적인 해결 방법이다. 오늘 소개할 방법은, 더 간단하게 jenkins 설정으로 예방하는 방법이다.빌드시 local repository를 비우고, 새로 clone받아 빌드하도록 한다. 빌드시나리오 &gt; 소스 코드 관리 &gt; additional behaviours 에 아래와같이 추가한다.빌드때마다 자동으로 정리해주어 수동으로 작업할 필요가 없어진다빌드시간이 느려질까봐걱정된다면 충돌날때만 해도 무방하다충돌자체를 방지하고싶은 경우, 빌드시나리오 작성하실때 추가해두셔도 좋은 옵션이다.","link":"/2019/09/25/jenkins-%EB%B9%8C%EB%93%9C%EC%8B%9C-git-branch-%EC%B6%A9%EB%8F%8C%ED%98%84%EC%83%81-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0/"},{"title":"JPA-DDD 2 (readonly로 관계 맺기 &#x2F; N+1 &#x2F; ...)","text":"readonly? department - line 관계를 맺고싶을때? 어떤 department가있다. 이department가 포함된 market - factory의 어떤 생산 line에서 제품을만든다 강결합정도에 따라 상호 참조 하지않고 service에서 로직으로 연관데이터 조합 readonly로 데이터 참조 read &amp; write가능 (-&gt; 지양하기, 하위 도메인취급이 되어버림) 보수적으로 설계 -&gt; 필요할때 하나씩 열어주는 방식으로 고려하면 :+1: case 1 기존 rule대로 약결합으로 구현하면 생기는 문제 merge data -&gt; stream / loop 의존성은 약하지만 비효율적임 하나의db / 하나의application이기때문 분리가되면 db도, 모듈도 분리가되어버린다. case 2 read only 로 설정방법123456789101112131415161718192021222324252627282930313233343536373839@Table(name = &quot;suppliment&quot;)@Entity...public class Suppliment { @Id private long suppliment; //1. 키 데이터 O, 데이터 직접 참조 X @Column(name=&quot;market_id&quot;) private long marketId; @Column(name=&quot;factory_id&quot;) private long factoryId; //2. 데이터 직접 참조 O, //save 될때 side effect -&gt; cascade에 따라 발생 가능 &lt;- 위험 //데이터 직접 바꾸는것 가능 O @ManyToOne(cascade=CascadeType.ALL) @JoinColumn(name=&quot;market_id&quot;) private Market marketId; @ManyToOne(cascade=CascadeType.ALL) @JoinColumn(name=&quot;factory_id&quot;) private Factory factoryId; //3. 데이터 직접 참조 O, //save 될때 side effect -&gt; cascade 설정을 하지않아서 함깨 바뀌는것을 방지. //updatable, insertable 을 false로 두어 root도메인을 건드리지못하게한다. @ManyToOne @JoinColumn(name=&quot;market_id&quot;, updatable = false, insertable = false) private Market market; @ManyToOne @JoinColumn(name=&quot;factory_id&quot;, updatable = false, insertable = false) private Factory factory;} 더 작은 서비스로.. root 에그리거트를, module로 분리하게되면? applicaton의 기술스택 뿐 아니라 db도 분리가가능 db 분리시 기존에 사용하던 db말고 다른 플랫폼을 사용 할 수 있다 join이 당연히 불가능함 &lt;– 고려사항 실제로 insert/update 용 DB와 select용 DB를 따로 쓰도록 설계하기도한다.(CQRS) @OnetoOne 의 optional=false와, @Column의 nullable=falses repository Market 도메인을 위한 repository를 만들어보자. JpaRepository&lt;Entity, Type of EntityKey&gt; 를 extends 한 interface를 만든다. 12345678public interface MarketRepository extends JpaRepository&lt;Market, Long&gt; { Market findByMarketId(Long marketId); //findAll //saveAll //.... // 이 자동으로 포함되어있다} select1234567public Collection&lt;Market&gt; findAll() { Collection&lt;Market&gt; allMarket = marketRepository.findAll();}public Collection&lt;Market&gt; findById(Long key) { Market market = marketRepository.findByMarketId(key);} insert123public void insert(Market market) { marketRepository.save(market);} -&gt; 1:n에서 불필요하게 query가 많이 날아가는경우가있다. (N+1 문제라고한다. 뒤에 설명) updatesave가 같은역할을 함123public void update (Market market) { marketRepository.save(market)} N+1 문제 ★★★★N+1 문제란?부모객체의 데이터를 가지고오는 경우 select쿼리 호출 횟수가 기하급수로 늘어나는현상.부모데이터 select 1번 + 자식 데이터 수만큼 select성능에 막대한 영향을 미침. Q 아래와 같이 데이터가 쌓인경우, query 호출횟수는? market - 10 row address - 10 row department - 각각 10row car - 각 10row building - 각 10 row 답 :10 + 10x(department)= 10 + 10x(10+ 10x(cars + building))= 10 + 10x(10+ 10x(10 + 10))= 2110 –&gt; 한번에 join을 걸어서 가지고오면 좋을탠데.. jpql Java Persistence Query Language JPQL은 SQL과 비슷한 문법을 가진 객체 지향 쿼리 String jpql = &quot;select c from Category c &quot;; 처럼 사용 QueryDSL ★★ 원하는대로 join 가능 복잡한쿼리 가능 custom하게 where절 만들기 가능 (매우매우 단순한 applicatoin 이 아니라면 쓰게 custom 한 쿼리를 짜게됨…) jpql에 비해 얻을수 있는점 IDE의 코드 자동 완성 기능 사용 문법적으로 잘못된 쿼리를 허용하지 않음 도메인 타입과 property를 안전하게 참조할 수 있음 더 많은 타이핑이필요 예를들면 아래와 같은것들이 가능하다 123456789101112131415public Market find(String, departmentsName, String carName){ return from(market) .innerJoin(market.departments, department ) .fetchJoin() .innerJoin(department.cars, car) .fetchJoin() .where( department.name.eq(departmentsName), car.name.eq(carName) // market.registerDatetime.after(xxx) // market.registerDatetime.before(xxx) //... )} 설정방법 buildscript에 plugin 추가 build.gralde (root)1234567891011121314151617buildscript { ext { springBootVersion = '2.0.5.RELEASE' querydslPluginVersion = '1.0.10' } repositories { mavenCentral() jcenter() maven { url &quot;https://plugins.gradle.org/m2/&quot; } } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) classpath(&quot;gradle.plugin.com.ewerk.gradle.plugins:querydsl-plugin:${querydslPluginVersion}&quot;) }} 의존성 추가 build.gradle (module)123456789101112dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)... compile (&quot;com.querydsl:querydsl-core:${querydslVersion}&quot;) compile (&quot;com.querydsl:querydsl-apt:${querydslVersion}&quot;) compile (&quot;com.querydsl:querydsl-jpa:${querydslVersion}&quot;)...}// query dsl 에 관한 내용은 별도파일로 관리했음.apply from: &quot;$projectDir/queryDsl.gradle&quot; 플러그인적용 및 querydsl Task 추가 queryDsl.gradle 123456789101112131415161718// querydsl 적용apply plugin: &quot;com.ewerk.gradle.plugins.querydsl&quot; // Plugin 적용def querydslSrcDir = 'src/main/generated' // QClass 생성 위치querydsl { library = &quot;com.querydsl:querydsl-apt&quot; jpa = true querydslSourcesDir = querydslSrcDir}sourceSets { main { java { srcDirs = ['src/main/java', querydslSrcDir] } }} repository에 적용생성된 테스크를 수행하면 generated 폴더에 QClass가 생성됨 QClass란? @Entity 가 붙은 class들을 찾아 자동으로 생성함 EntityPathBase 과같이 `EntityPathBse 를 상속함 entity 의 구성요소 등을 파악하여 쿼리를 생성할수있게 도아줌 query dls 은 해당 class를 기반으로 table -&gt; from / member variable -&gt; columns 로 매칭하여 쿼리를 만들수 있게 도아줌 적용방법MarketRepository.java12345678public interface MarketRepository extends JpaRepository&lt;Market, Long&gt; , MarketRepositoryCustom { Market findByMarketId(Long marketId); //findAll //saveAll //.... // 이 자동으로 포함되어있다} MarketRepositoryCustom.java123public interface MarketRepositoryCustom { Market findWithoutBuildingByDepartmentNameAndCarName(String DepartmentName, String CarName);} 123456789101112131415161718public class MarketRepositoryCustomImpl extends QuerydslRepositorySupport implements MarketRepositoryCustom { QMarket market = QMarket.market; QDepartment department = QDepartment.department; QCar car = Qcar.car; public Market findWithoutBuildingByDepartmentNameAndCarName(String DepartmentName, String CarName) { return from(market) .innerJoin(market.departments, department ) .fetchJoin() .innerJoin(department.cars, car) .fetchJoin() .distinct() //중복제거 .where( department.name.eq(departmentsName), car.name.eq(carName) ) }} MarketService.java123public getSomething(){ marketRepository.findWithoutBuildingByDepartmentNameAndCarName(&quot;payco&quot;, &quot;bungbung&quot;);} 구조123456789101112interface MarketRepositoryinterface MarketRepositoryCustominterface JpaRepository class MarketRepositoryCustomImplclass MarketServiceMarketRepository &lt;|- JpaRepository : extendsMarketRepository &lt;|- MarketRepositoryCustom : extends MarketRepositoryCustom --&gt; MarketRepositoryCustomImpl : implments MarketService &lt;-- MarketRepository : DI quertdsl where절 활용하기where절 조회 파라메터가 empty 값일때 무시하기 1 null check 후 eq를 비교한다12345678910111213141516171819202122public Market findWithoutBuildingByDepartmentNameAndCarName(String DepartmentName, String CarName) { return from(market) .innerJoin(market.departments, department ) .fetchJoin() .innerJoin(department.cars, car) .fetchJoin() .distinct() //중복제거 .where( equalsIfNotNull( department.name, departmentsName), equalsIfNotNull(car.name, carName) car.name.eq(carName) )} private BooleanExpression equalsIfNotNull(StringPath column, String param) { return param== null ? null : column.eq(param);}private BooleanExpression equalsIfNotEquals(StringPath column, String param) { return StringUtils.isEmpty(param) ? null : column.eq(param);}.... 단점 : string 같은경우 empty check를해야함 날짜의 경우 before/after를 비교하고싶음 …. where절 조회 파라메터가 empty 값일때 무시하기 212345678910111213public Market findWithoutBuildingByDepartmentNameAndCarName(String DepartmentName, String CarName) { return from(market) .innerJoin(market.departments, department ) .fetchJoin() .innerJoin(department.cars, car) .fetchJoin() .distinct() //중복제거 .where( WhereClauseBuilder.optionalAnd( department.name, department.name.eq(departmentsName)), WhereClauseBuilder.optionalAnd( car.name, car.name.eq(carName)) ) } 12345678910111213141516171819public class WhereClauseBuilder { public static &lt;T&gt; BooleanExpression optionalAnd(T param, BooleanExpression booleanExpression) { if (param instanceof String) { String stringParam = (String) param; if (StringUtils.isEmpty(stringParam)) { return null; } else { return booleanExpression; } } if (param != null) { return booleanExpression; } return booleanExpression }} where절 조회 파라메터가 empty 값일때 무시하기 3 조금만더 발전시켜보자 lazy loading 123456789101112public Market findWithoutBuildingByDepartmentNameAndCarName(String DepartmentName, String CarName) { return from(market) .innerJoin(market.departments, department ) .fetchJoin() .innerJoin(department.cars, car) .fetchJoin() .distinct() //중복제거 .where( WhereClauseBuilder.optionalAnd( department.name, ()-&gt;department.name.eq(departmentsName)), WhereClauseBuilder.optionalAnd( car.name, ()-&gt;car.name.eq(carName)) ) } 12345678910111213141516171819public class WhereClauseBuilder { public static &lt;T&gt; BooleanExpression optionalAnd(T param, LazyBooleanExpression booleanExpression) { if (param instanceof String) { String stringParam = (String) param; if (StringUtils.isEmpty(stringParam)) { return null; } else { return booleanExpression.get(); } } if (param != null) { return booleanExpression.get(); } return null; }} 12345@FunctionalInterfacepublic interface LazyBooleanExpression { BooleanExpression get();} where절 조회 특정 조건일때 무시하기 31public static BooleanExpression ignoreAnd(boolean isTrue, LazyBooleanExpression booleanExpression) one to one에서 방향 기존 mysql rdb 기반에서의 구조 child가 자신의 id를 가지고, 부모의 키를 fk로 가진다 one to one 관계에서 lazy loading이 불가능해진다. http://whiteship.me/?p=13301 JPA에서 추구하는 방향 관계의 맺고 끊음 주체가 되는 도메인, 즉 부모측에서 key를 관리 한다. 매핑이 되는 key를 공통으로 사용하더라도 이슈가 없다. eticket에서는? 1:1은 부모와 자식을 같은키로 사용 tipsboolean123@Type(type = &quot;yes_no&quot;)@Column(name = &quot;pin_search_success_yn&quot;)private boolean isSucceeded; @Type(type = “yes_no”) 붙여주면 db값의 y,n 을 true/false로 바꿔주어 boolean으로 사용가능하다","link":"/2021/06/15/jpa-ddd-2/"},{"title":"JPA-DDD 3 (단방향vs양방향, 중복된 컬럼 객체 문제)","text":"one to many 관계에서 단방향 vs 양방향단방향의 문제점 ( / 양방향의 장점) 부모 insert -&gt; 자식 insert -&gt; 자식의 부모키를 update??? https://velog.io/@dpudpu/5 해결방법 부모측에서 nullable 을 설정해준다. 이렇게 해놓고 컴파일을 해보면 org.hibernate.MappingException 이 나올탠데 (should be mapped with insert=”false” update=”false”) 라는 안내문구가나온다 자식쪽에는 insertable = false,updatable = false 를 셋팅해주면 컴파일이 된다 부모12@JoinColumn(name = &quot;car&quot;, nullable = false)private List&lt;Car&gt; Cars;자식12@JoinColumn(name = &quot;resource_id&quot;, insertable = false,updatable = false)private List&lt;Car&gt; resourceId; 서비스란 ? - application service / domain service application service domain service 주역할 transaction관리 도메인에서 맡아야할 비지니스 로직 관리 권한범위 다양한 도메인/레파지토리에 역할을 배분 자신의 도메인 영역에서만 로직 수행 영향범위 transaction종료시 다양한도메인에 영향 다른도메인에서는 값만 받아 처리하므로 자신의도메인 Hibernate’s MultipleBagFetchExceptionnested @OneToMany에서 select를 한다면Hibernate’s MultipleBagFetchException - Hibernate cannot simultaneously fetch multiple bags 문제가 발생한다에러메시지에서 나오는 bag 은 Hibernate에서 데이터를 가지고올때 사용하는 자료구조인 Bag이다. market -&gt; resource -&gt; cars 에는 1:N 관계가 2번 중첩된다이런경우 위와같은 에러가 발생하는데단순히 List -&gt; Set으로 변경해주면 해결이된다순서가 걱정이라면 LinkedHashSet 으로 처리가능하다 중첩된 컬럼 객체 문제nested @OneToMany에서 부모객체는 List형태로 자식 데이터를 가지고 있는데select를 해보면, list size 가 child 수만큼 있는 경우가 발생한다단순히 자료형을 set으로 바꿔주거나 , distinct를 넣어 해결한다.","link":"/2021/06/15/jpa-ddd-3/"},{"title":"querystring  jquery 로 쉽고 명확하게 만들기","text":"javascript상에서 쿼리스트링을 생성하여 redirect하거나, 비동기로 요청을 해야하는 경우가 있다.간단하게는 string을 직접 생성하여 사용하는 방법도 있다.jquery는 좀더 우아한 코드작성에 도움을 준다, 파라메터가 복잡할수록 가독성도 좋아진다. 파라메터가 하나 추가될때 이전방식은 변수선언과 url합성을 동시에 해야하는반면,jquery를 사용했을때는 들어가는 object의 내용만 바꿔주면된다. before1234567var id = &quot;myId&quot;;var name = &quot;myName&quot;;var age = &quot;20&quot;window.location = 'http://localhost:7000?' + '&amp;id=' + id + '&amp;name=' + name '&amp;age=' + age; after1234567var url = 'http://localhost:7000';var obj = { id : 'myId', name : 'myName', age : 20 };window.location = url +'?' + $.param(obj);","link":"/2019/04/03/jquery%EB%A1%9C-query-string-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"지극히 개인적인 맥북 초기셋팅","text":"java-spring을 메인으로 사용하는 개발자 기준입니다.맥북을 신규로구입한 경우 셋팅할 내용을 간단히 적어보았습니다. mac os update xcode 설치 terminal (iterm2) : https://www.iterm2.com/ 추가설치 및 셋팅 : https://medium.com/harrythegreat/oh-my-zsh-iterm2로-터미널을-더-강력하게-a105f2c01bec develop tools jdk : https://adoptopenjdk.net/ source code git : https://git-scm.com/download/ git kraken : https://www.gitkraken.com/download (o) sourcetree : https://www.sourcetreeapp.com/ (x) intellij : https://www.jetbrains.com/ko-kr/idea/download/ mysql : https://downloads.mysql.com/archives/workbench/ 악성 소프트웨어 오류시 : https://seyul.tistory.com/78 postman https://www.postman.com/downloads/ node https://nodejs.org/en/ etc font (d2) : https://github.com/naver/d2codingfont/releases/tag/VER1.3.2 hosts 변경 수동 : http://www.devkuma.com/books/pages/1191 툴사용 : https://github.com/specialunderwear/Hosts.prefpane","link":"/2021/06/16/macbook-setting/"},{"title":"nginx location 설정 - 정규식 operation 우선 순위","text":"nginx location 설정 operation 우선 순위가정url 별로 접근 권한을 다르게 주고싶다고 가정하자.접근권한은 url, userAgent, referer(referrer) 같은 변수를 통해 다양한 방법으로 정할수 있다.그중 가장 먼저 적용 할 수 있는 url path 를 통한 방법에 대해 알아보자. 특정 path는 static한 메시지를 보여주자! 특정 path로 시작하는 페이지는 모두에게 보여주자 나머지는 userAgent 와 referer(referrer)로 판단하자. 방법 위에 언급한 path 별 권한설정을 하기위해 nginx 설정중 location 부분을 설정해주어야한다 location 설정은 위에 있는것이 먼저 적용되는것이 아니다, 매칭 방식에 따라 우선순위가 결정된다. 우선순위 : = : 정확하게 일치해야함 ^~ : 앞부분이 일치 ~ : 정규식 대 / 소문자 구분 ~* : 대소 문자를 구분하지 않는 정규 표현식 : location ~*. (jpg | png | bmp) / : / 이하는 모두 매칭되는데 우선순위가 제일 낮다. 이후 동일한 순위인경우 위에것이 먼저 적용된다.","link":"/2019/02/01/nginx-location%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC/"},{"title":"[mybatis] 파라메터 ${}, #{} 차이점 정리","text":"${}, #{}mybatis mapper에서 parameter를 받아서 사용할때 크게 2가지 방법이 있다.${}, #{} 두가지 방법은 동작이 다르고 경우에따라서는 보안상으로 좋지 않으므로 차이점을 명확히 알고 사용해야한다. ${} : 원문 그대로 -&gt; 잠재적 sql injection 취약점 - 주의해서 사용 #{} : ' ' 를 씌워줌, sql injection 방지 파라메터 - ParametersParameters는 마이바티스에서 매우 중요한 엘리먼트이다. 대략 90%이상은 간단한 경우 이러한 형태로 설정한다. 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select id, username, password from users where id = #{id}&lt;/select&gt; #{} 문법은 마이바티스로 하여금 PreparedStatement프로퍼티를 만들어서 PreparedStatement파라미터(예를들면 ?)에 값을 셋팅하도록 할 것이다. 위의 쿼리로 예를 들면 123select id, username, passwordfrom userswhere id = ? 이후 ? 에 값을 대입한다. ( ' 도 같이 추가해준다. )이때 ? 에 들어올 데이터가 달라지더라도 mysql같은 rdb에서 동일한 쿼리로 인식한다따라서 1,2,3,4, 값이 바뀌어도 새로 파싱을 하지 않는다. 아래와같은 문법으로 type을 지정해줄수도 있다1#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler} 문자열 대체 String Substitution가끔은 SQL 구문에 변하지 않는 값으로 삽입하길 원하기도 한다. 예를들면 ORDER BY와 같은 구문들이다. 이럴때는 #{} 을 사용하면 string 에 따옴표를 추가하므로 문법 오류가 발생 할 수 있다.이런경우 ${} 를 사용할 수 있다. 1ORDER BY ${columnName} 마이바티스는 문자열을 변경하거나 이스케이프 처리하지 않는다.사용자 입력값에 대해서는 언제나 자체적으로 이스케이프 처리하고 체크해야 한다. 정적 바인딩12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select id, username, password from users where id = ${id}&lt;/select&gt; ${} 로 바인딩을 하게되면 정적으로 쿼리에 값이 들어가게 되는데 123select id, username, passwordfrom userswhere id = 1 123select id, username, passwordfrom userswhere id = 2 이경우 값이 바뀌면 쿼리가 여러개 생성된다. 그리고 파싱도 여러번 하게되므로 성능상 #{} 보다 불리하다 위험성 사용자 입력값에 대해서는 이 방법을 사용하면 안된다. 만약 이 값이 사용자의 입력을 통해 전달된다면 위험 할 수 있다.사용자가 입력한 값이 그대로 쿼리에 적용되기 때문이다. 잠재적인 SQL 주입 공격에 노출된다. 참고자료https://mybatis.org/mybatis-3/sqlmap-xml.html","link":"/2020/03/13/mybatis-difference/"},{"title":"nginx 디폴트 에러페이지 설정하기","text":"nginx의 기본 에러페이지nginx의 기본 에러페이지가 노출되는 현상은 서버 정보를 노출할수 있으니 커스텀한 페이지로 수정할것을 권장한다. 가이드http status code 에따라서 디폴트 에러페이지를 지정할 수 있다경로는 yum 을 이용해 nginx를 설치한 기본경로로 가정한다. 설정파일의 기본경로:/usr/local/nginx/conf/nginx.conf nginx의 static page또한 설치방법마다 경로가 다르다, 하지만 수동으로 지정 가능하다.기본경로는 /usr/share/nginx/html 으로 되어있을것이다. 123456789101112131415server { listen 443 ssl; server_name hyeonguj.github.io; .... location / { proxy_pass http://127.0.0.1:8080; .... } error_page 403 404 405 406 411 497 500 501 502 503 504 505 /error.html; location = /error.html { root /usr/share/nginx/html; }} http status code 에따라서 디폴트 에러페이지를 지정할 수 있다. 추가 사항http status 497http://127.0.0.1:443/path 와 같이 호출하는경우http 임에도 불구하고 443 포트를 직접 연결 하는것은 허용하지않는데. 이 경우 http status가 497로 떨어진다 권장사항서비스에 의존성이 있는 페이지가아닌 static한 에러페이지를 사용할것을 권장한다.상대경로가 들어가게되면 리소스를 찾지못해 깨진 페이지가 나올 수 있다.","link":"/2019/09/25/nginx-%EB%94%94%ED%8F%B4%ED%8A%B8-%EC%97%90%EB%9F%AC%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"spring boot 2.x + jsp +gradle 내장톰켓 셋팅하기","text":"프로젝트 구성 개요 jsp를 쓸수밖에 없는 프로젝트에서 gradle을 이용하여 war로 build 후 java -jar app.war 를 사용하여 프로젝트를 띄울수 있게 하는것이 주 목적이다. spring boot 프로젝트러 jar패키징후 내장 톰켓을 사용하는 방식으로는 jsp 를 view template으로 사용할수 없다. 이 셋팅이 필요없는 케이스. 굳이 jsp를 쓰지않아도 되는 경우. war셋팅도 필요없으니 기존 jar 배포구조로 구성하면된다. 내장tomcat을 쓰지않는경우. war로 패키징하여 외부 톰켓을 이용하면 되므로 bootRun, bootWar셋팅까지 할 필요는 없다. 실제로는 프로젝트를 마이그레이션 하는 과정에서 발생한 트러블 슈팅 과정을 정리한 산출물입니다.본 내용에서는 마이그레이션 과정이 아닌 셋팅만 기술하겠습니다.(결과물위주) 디렉토리 구조12345678910111213src.main├ com.project..../| ├ controller/| └ service/├ resources/| ├ config/| | └ applicatoin.yml| └ properties/| └ webapp/ ├ test.jsp ├ error.jsp jsp를 뷰 template으로 사용하기 위해서는 src/main/webapp 페키지 아래 둔다. 빌드 환경과 의존성 셋팅 war로 build 하기위해서 apply plugin: 'war' 를 포함시켜준다. 이제 gradle - build 시 jar가 아닌 war로 빌드된다. 내장톰켓이 jsp를 실행시킬수 있도록 의존성을 추가한다 tomcat-embed-jasper jstl war plugin을 설치하면 gradle build에서 war, bootWar를 선택할 수 있다. 이를 셋팅해준다 (선택사항) 위과정을 bootRun에서 수행하고싶다면 개발환경을 위해 bootRun 까지 셋팅해준다. main = bootWar.getMainClassName() 를 추가해주면 war를 생성해 실행해준다. 로컬환경 설정 변경하기 (intellij 만 해당) AppApplication - run으로 실행되지 않는 경우가있다 multi module project 인경우 발생한다 run/debug configuration &gt; environment &gt; Workingdirectory 를 $MODULE_WORKING_DIR$ 로설정하면 해결된다. 예시아래는 1~4에 해당하는 부분을 적용한 build.gradle 예시이다 123456789101112131415161718192021222324252627282930313233apply plugin: 'war' //setting 1ext { jstlVersion = '1.2' //알맞게 바꿔 사용하세요 jasperVersion = '9.0.14'}dependencies { /* Web */ compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) compile(&quot;org.springframework.boot:spring-boot-configuration-processor&quot;) /* jsp */ //setting 2 compile(&quot;org.apache.tomcat.embed:tomcat-embed-jasper:${jasperVersion}&quot;) compile(&quot;javax.servlet:jstl:${jstlVersion}&quot;) /* db */ /* add dependencies what you need!! */}//setting 3bootWar { mainClassName = 'com.project.MainApplication' archiveName = rootProject.name + '-' + baseName + '.' + extension}//setting 4bootRun { main = bootWar.getMainClassName() systemProperties = System.properties} 배포하기 bootWar 명령어를 통해 빌드 build/libs 안에 war 파일을 서버에 배포 java -jar app.war 명령어로 실행","link":"/2019/02/14/spring-boot-2-x-jsp-gradle-%EB%82%B4%EC%9E%A5%ED%86%B0%EC%BC%93-%EC%85%8B%ED%8C%85%ED%95%98%EA%B8%B0/"},{"title":"Spring boot - local tomcat 에서 ssl 설정하","text":"동기최근 chrome80 의 cookie 정책변경으로 저자가 서비스하는 모든 서비스들을 https로 운영하기로 했다. 관련 이슈는 여기 (https://hyeonguj.github.io/2020/02/05/chrome80/ ) 에 정리하였다. 기존에는 local환경과 개발서버에서는 http로 통신을 하며 작업을 하였으나 바뀐 정책에서 쿠키를 읽기위해서는 https로 서비스를 해야한다. 개발서버의 경우 apache나 nginx에서 모두 http -&gt; https로 바꾸어주며, 인증서 처리가 되어있기때문에 문제가 되지 않는다. 하지만 local 환경의 경우 tomcat 또는 spring boot application에서 https로 서비스를 할 수 있어야 테스트가 가능하다. Spring boot https 활성화하기우선 ssl 인증서를 준비한다.만드는 방법은 아래와 같다 windows 기준 keytool -genkey -alias tomcat -keyalg RSA -validity 3650 -keystore tomcat.keystore mac sudo keytool -genkey -alias tomcat -keyalg RSA -validity 3650 -keystore 1234567891011121314151617keytool -genkey -alias tomcat -keyalg RSA -validity 3650 -keystore tomcat.keystoreEnter keystore password: Re-enter new password: What is your first and last name? [Unknown]: What is the name of your organizational unit? [Unknown]: What is the name of your organization? [Unknown]: What is the name of your City or Locality? [Unknown]: What is the name of your State or Province? [Unknown]: What is the two-letter country code for this unit? [Unknown]: Is CN = Unknown, OU=Unknown, O = Unknown, L = Unknown, ST = Unknown, C = Unknown correct? [no]: yes 그리고 application.yml에 아래와 같이 설정해주도록 한다.123456789server: ssl: enabled: true key-alias: tomcat key-password: 설정한 비밀번호 key-store: tomcat.keystore의 경로/tomcat.keystore key-store-provider: SUN key-store-type: JKS key-store-password: 설정한 비밀번호 마지막으로 application을 실행해서 https로 접속하여 확인하자. local tomcat 에서 ssl 설정하기spring boot web application이 아닌경우라면 로컬환경에서 톰켓을통해 실행할 가능성이 크다. 이런경우에도 동일하게 인증서를 먼저 생성해준다. 이후 아래와같이 https 포트를 지정해준다 그리고 local tomcat 의 server.xml에 아래 항목을 추가한다 1234567&lt;!-- Define an SSL Coyote HTTP/1.1 Connector on port 8443 --&gt;&lt;Connector protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; port=&quot;8443&quot; maxThreads=&quot;200&quot; scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot; keystoreFile=&quot;tomcat.keystore 파일의 경로&quot; keystorePass=&quot;2번에서 설정한 비밀번호&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;/&gt;","link":"/2020/02/05/spring-boot-enable-https/"},{"title":"spring boot 예제 - 웹 프로젝트 만들기","text":"spring boot 예제spring boot를 이용하여 웹페이즈를 만드는 샘플 프로젝트를 소개하려한다. 작업한 소스코드 예시는 github에 공유하고있습니다.https://github.com/HyeonGuJ/demo-spring-boot-web spring boot는 spring에서 작업했던 설정들을 보다 쉽게 할 수 있고, 첫 페이지를 만들기까지 시간이 오래걸리지 않는다. spring initializr를 통해 원하는 기능들을 조합하고 IDE를 통해 페이지를 띄우는것까지 진행해보자. 시간이 없다면 3. 프로젝트 생성하기로 넘어가세요. spring initializr를 통해 프로젝트 생성spring initializr는 spring으로 application을 만들기 시작할때 필요한 의존성을 자동으로 셋팅하여 구조를 잡아주기 때문에 application을 처음 만들때 사용하면 매우 좋다. 사용법사용법은 크게 2가지가있다. 웹사이트에서 원하는 항목을 선택 후 소스코드를 다운로드 받는 방법 (https://start.spring.io) IDE 에서 제공하는 도구를 사용하는 방법 IDE마다 지원여부가 다름 IntelliJ는 지원 STS 는 지원하지않음 (2018년기준) spring initializr를 사용할때 필요한 대부분의 작업은 의존성을 선택하는것에 초점이 맞춰져있다. 예제는 웹사이트에서 선택하는 방법으로 진행한다. 프로젝트 생성하기먼저 spring initializr 웹페이지에 접속한다. https://start.spring.io 화면을잠시 살펴보면 5가지 항목이 있다. 간단히 그 기능을 살펴보면 아래와 같다. Project : 의존성을 관리해주는 도구 - 라이브러리를 다운로드해준다 Language : 프로그래밍 언어 Spring Boot : spring boot 버전선택 Project Metadata : 프로젝트 정보, 일반적으로 도메인 역순 Dependencies : 필요한 의존성 선택하기 선택하기 Dependencies를 제외하면 위 스크린샷과 동일하게 진행한다. Project : gradle Language : java Spring Boot : 2.2.4 Project Metadata Group : com.hyeonguj Artifact : demo packaging : jar java : 8 Dependencies의존성은 웹 개발에 있어서 필수적인 요소는 매우 적다. 하지만 부가적인 다른 의존성들을 활용하면 개발생산성이 매우 향상되므로 이점도 포함시킨다. 가능한 필수적인 요소만 담으려고한다. api 동작 뿐 아니라 웹페이지 까지 포함된 서비스를 목표로 한다. db와 cloud,testing 등은 제외한다. 2020.02 기준 위에서부터 서술한다. developer tools spring boot dev tools lombok spring configuration processer web spring web template engine mustache 다음 링크를 통해 이동하면 위 항목을 모두 선택한 화면을 볼 수 있다. https://start.spring.io/#!type=gradle-project&amp;language=java&amp;platformVersion=2.2.4.RELEASE&amp;packaging=jar&amp;jvmVersion=1.8&amp;groupId=com.hyeonguj&amp;artifactId=demo&amp;name=demo&amp;description=Demo%20project%20for%20Spring%20Boot&amp;packageName=com.hyeonguj.demo&amp;dependencies=devtools,lombok,configuration-processor,web,mustache 이후 다운로드를 진행한다 개발환경 만들기압축 해제우선 다운로드 받은 압축파일을 원하는 경로에 풀어주자.아래 그림과 같이 src폴더와 함께 의존성을 관리하는 build.gradle 등이 보인다. IDEweb application을 만들기위해 준비하는과정이다. IDE 에 import하자. IDE는 IntelliJ를 사용한다. 개인적으로도 STS보다는 IntelliJ를 추천한다. 아래 링크를 통해 다운로드 받을 수 있다. 무료라이센스인 community 라이센스를 사용해도 무방하다.https://www.jetbrains.com/ko-kr/idea/download/ 그리고 이전에 압축해제한 경로를 import해준다.File &gt; Open 경로를 선택하면 필요한 라이브러리를 다운받는 등 개발에 필요한 작업을 자동으로 수행한다. 이미 이상태로 웹 서버를 띄울 준비는 모두 끝났지만, 아무런 기능이 없다. 첫 페이지 만들기프로젝트를 처음 셋팅하면 빠지지 않는 hello world를 만들어보자. 진입점 역할을 하는 controller를 생성한다. HomeController.java &lt;- 누르면 github 링크로이동1234567891011121314package com.hyeonguj.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HomeController { @GetMapping public String home() { return &quot;welcome&quot;; }} welcome.muastache &lt;- 누르면 github 링크로이동12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello world!&lt;/body&gt;&lt;/html&gt; 폴더 구조는 다음과 같다 실행해보기그리고 DemoApplication을 run 시킨다. 수행하면 console 화면에는 기본설정인 8080포트로 정상적으로 웹서버가 작동한다는 문구를 볼 수 있다. 웹 브라우저를 열고 http://locahost:8080 에 접속해보면 hello world 문구를 볼 수 있다","link":"/2020/02/19/spring-boot-example-web/"},{"title":"spring-boot - logback profile 설정하기, 설정전략 (logback-spring.xml)","text":"logback지난포스트 에서 logback의 기본적인 설정에 관하여 다루었다.이번 포스팅에서는 logback-spring.xml과 profile로 설정을 나누는 방법, 그리고 그 전략에 대해 다룬다. logback-spring.xmlspring에서 logback은 설정파일을 아래와같은 순서로 찾는다. logback.groovy logback-test.xml logback.xml default spring-boot의 경우 조금 다르게 logback-spring.xml이라는 이름으로 설정한다.logback.xml 으로 설정하면 spring-boot 가 설정되기전에 로그백설정을 완료한다. 따라서 spring-boot에서 사용하는 properties 나 profile같은 설정값을 사용할 수 없게된다. profile에 따라 로그설정기본적인 logback.xml에 관한 설정은 logback 기본설정 포스팅에서 다루고 profile 설정에 관해 알아보자. 필자는 크게 console에 로깅, file에 로깅, 그리고 logstash로 로그를 전송하는 3가지 설정을 하였다.그리고 profile별로 아래와같이 나누었다. phase에 따라서 proflies를 나누는 경우에는 아래와같이 설정 할 수 있다 1234567891011121314151617&lt;root&gt; &lt;springProfile name=&quot;local&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;alpha&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE-ASYNC&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;release&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE-ASYNC&quot;/&gt; &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt; &lt;/springProfile&gt;&lt;/root&gt; profile에 따른 로깅전략또다른 전략으로는 로깅방법에 따라서 profile에 추가해주는 방법이 있는데, appender 갯수가 늘어남에 따라 조합은 다양해지기때문에 필자는 이와같은 방법을 선호한다. -DSpring.profiles.active=console-logging,file-logging,logstash-logging 으로 넣어준다면 3개의 appender가 모두 작동할것이다.그리고 local환경과같이 console로깅만 필요한 경우 -DSpring.profiles.active=console-logging면 충분하다. 1234567891011&lt;root&gt; &lt;springProfile name=&quot;console-logging&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;file-logging&quot;&gt; &lt;appender-ref ref=&quot;FILE-ASYNC&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;logstash-logging&quot;&gt; &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt; &lt;/springProfile&gt;&lt;/root&gt; -DSpring.profiles.active=console-logging,file-logging,logstash-logging 와같은 긴 설정이 불편하고 위처럼 phase에따라서 설정하게 만들고 싶다면 application.yml 을 수정하여 아래처럼 할수도 있다. 아래 예제는 위 profile에 따라 로그설정 에서 다룬 예제와 동일하게 동작한다 12345678910111213141516spring: profiles: include: console-logging---spring: profiles: alphaspring: profiles: include: console-logging,file-logging---spring: profiles: releasespring: profiles: include: console-logging,file-logging,logstash-logging","link":"/2020/01/22/spring-boot-logback-profile-%EC%84%A4%EC%A0%95-logback-spring-xml/"},{"title":"spring-boot - logback 설정 - logback.xml","text":"spring boot logging스프링부트는 모든 내부 로깅에 Commons Logging를 사용한다, 그러나 근원적인 로그 구현체를 열어볼 수 있다. 기본 설정들은 Java Util Logging, Log4j 그리고 Logback을 제공한다. 각각 콘솔로 출력되고 파일로 출력된다. (10MB 크기가 되면 파일을 새로 생성) 기본적으로, ‘Starter POMs’를 사용한다면, Logback을 로깅에 사용할 것이다. 유연한 Logback은 Java Util Logging, Commons Logging, Log4j 혹은 SLF4J 를 사용하는 의존적 라이브러리들을 의존적인 라이브러리들도 문제없이 동작하는 것을 보장한다. 팁: 자바에서 사용가능한 로깅 프레임워크들은 대부분 지원한다. 목록만 보고서 당혹러워할 이유는 없다. 기본적으로 로깅 의존성을 변경할 필요는 없을 것이며 스프링부트는 기본적으로 잘 되어 있어있다. logback의존성spring-boot-starter-logging 를 포함하고있는 starter를 사용하는것이 가장 쉽다. 웹 에플리케이션을 구성한다면 spring-boot-starter-web 만 있으면 된다. 설정더 상세한 설정을 위해서는 각 구현체가 요구하는 설정양식을 사용하여야 한다.기본적으로 스프링부트는 설정파일을 기본 경로에서 찾으며 Logback의 경우 classpath:logback.xml 이다.spring logback.xml 설정파일 최상단에는 configuration가 자리잡고있다. 로그를 출력하는 방법에따라 appender를 설정해준다. console 창에 추가하는 ConsoleAppender 로그를 file에 남기기위한 FileAppender elk stack을 활용한다면 logstash 와 관련된 appender root블럭은 모든 defautl설정이라고 보면된다 &lt;root level = &quot;INFO&quot;&gt; 라고되어있다면 INFO이상 등급에대해 로그를 남긴다 이외에 추가 설정으로 특정 logger에서만 로그를 남기게 할 수 있다 console logging 예시1234567&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;appender name = &quot;STDOUT&quot; class = &quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&lt;/appender&gt; &lt;root level = &quot;INFO&quot;&gt; &lt;appender-ref ref = &quot;STDOUT&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; file logging 예시123456789&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;appender name = &quot;FILE&quot; class = &quot;ch.qos.logback.core.FileAppender&quot;&gt; &lt;File&gt;/var/tmp/mylog.log&lt;/File&gt; &lt;/appender&gt; &lt;root level = &quot;INFO&quot;&gt; &lt;appender-ref ref = &quot;FILE&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt;","link":"/2020/01/21/spring-boot-logging-logback-%EC%9C%BC%EB%A1%9C-%EB%A1%9C%EA%B9%85%ED%95%98%EA%B8%B0/"},{"title":"spring boot - @Test로 Controller API 호출 테스트하기 (통합테스트)","text":"spring boot 통합 테스트스프링 부트로 web 서버를 개발.client 입장에서 url로 호출시 controller가 잘동작 하는지 테스트하려고 한다. CodeBase Spring Test JUnit 4.x Hamcrest Mockito 1.x JsonPath SpringBootTest통합테스트 @ContextConfiguration 전체 환경이 다 로딩됨. 실제 애플리케이션 기동 시와 거의 유사 SpringBootTestSpringBootTest.WebEnvironment MOCK(default) : with MockMvc RANDOM_PORT : with embedded WAS DEFINED_PORT : with embedded WAS NONE : none Web. 일반 Service 테스트 시 용이 실제 Port를 알고 싶다면 @LocalServerPort 를 이용해서 주입 @TestConfiguration테스트 시에만 사용되는 구성SpringBootConfiguration 때문에 다른 테스트에서 참조될 수 있으므로 주의 요망 Mocking Mockito @MockBean @SpyBean @MockBean123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTest // !!!public class MyTests { @MockBean private RemoteService remoteService; @Autowired private Reverser reverser; @Test public void exampleTest() { // RemoteService has been injected into the reverser bean given(this.remoteService.someCall()).willReturn(&quot;mock&quot;); String reverse = reverser.reverseSomeCall(); assertThat(reverse).isEqualTo(&quot;kcom&quot;); }} @SpyBean12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTest // !!!public class MyTests { @SpyBean private RemoteService remoteService; @Autowired private Reverser reverser; @Test public void exampleTest() { // RemoteService has been injected into the reverser bean given(this.remoteService.someCall()).willReturn(&quot;mock&quot;); String reverse = reverser.reverseSomeCall(); assertThat(reverse).isEqualTo(&quot;kcom&quot;); then(this.remoteService).should(times(1)).someCall(); }} @WebMvcTest (slice) Spring MVC 환경이 통합된 상태이지만, 하나의 Controller를 테스트. 실질적으로 통합테스트 @AutoConfigureMockMvc를 이용하므로 MockMvc를 사용할 수 있음 value 넣어서 필요한 class만 로딩 @DataJpaTest Spring Data Jpa 환경이 통합된 상태로 Repository를 테스트할 수 있음. 실제 DB를 연동하거나 내장된 DB(ex:H2)를 사용할 수도 있음 @AutoConfigureTestDatabase(replace=Replace.NONE) 기본적으로 트랜젝션 처리도 가능하며 기본전략은 Rollback Example12345678910111213@RunWith(SpringRunner.class)@DataJpaTestpublic class ExampleRepositoryTests { @Autowired private UserRepository repository; @Test public void testExample() throws Exception { User user = this.repository.findByUsername(&quot;sboot&quot;); assertThat(user.getUsername()).isEqualTo(&quot;sboot&quot;); assertThat(user.getVin()).isEqualTo(&quot;1234&quot;); }} @RestClientTest 통신할 서버를 mocking해서 restClient를 테스트 가능하게 함 jackson, GSON 지원 Example123456789101112131415161718@RunWith(SpringRunner.class)@RestClientTest(RemoteVehicleDetailsService.class)public class ExampleRestClientTest { @Autowired private RemoteVehicleDetailsService service; @Autowired private MockRestServiceServer server; @Test public void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() throws Exception { this.server.expect(requestTo(&quot;/greet/details&quot;)) .andRespond(withSuccess(&quot;hello&quot;, MediaType.TEXT_PLAIN)); String greeting = this.service.callRestService(); assertThat(greeting).isEqualTo(&quot;hello&quot;); }} Utils : EnvironmentTestUtilsEnvironmentTestUtils.addEnvironment(env, &quot;org=Spring&quot;, &quot;name=Boot&quot;); Utils : TestRestTemplate통합테스트용 (ex: @SpringBootTest) 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class RandomPortTestRestTemplateExampleTests { @Autowired private TestRestTemplate restTemplate; @Test public void exampleTest() { String body = this.restTemplate.getForObject(&quot;/&quot;, String.class); assertThat(body).isEqualTo(&quot;Hello World&quot;); }} Utils : WebTestClient &lt;&lt;개인적으로 추천TestRestTemplate과 유사하나 fluent api를 지원 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class RandomPortWebTestClientExampleTests { @Autowired private WebTestClient webClient; @Test public void exampleTest() { this.webClient.get().uri(&quot;/&quot;).exchange().expectStatus().isOk() .expectBody(String.class).isEqualTo(&quot;Hello World&quot;); }} 출처 https://github.com/spring-projects/spring-boot/blob/1.5.x/spring-boot-samples/spring-boot-sample-test/src/main/java/sample/test/service/RemoteVehicleDetailsService.java https://github.com/spring-projects/spring-boot/blob/master/spring-boot-samples/spring-boot-sample-test/src/test/java/sample/test/service/RemoteVehicleDetailsServiceTests.java Test auto-configuration annotations https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/htmlsingle/#test-auto-configuration","link":"/2019/02/01/spring-boot-%ED%86%B5%ED%95%A9-test/"},{"title":"spring - multiple implements : interface - 인터페이스의 구현체를 동적으로 선택하는 방법","text":"동기본 글은 interface 란? spring 주입받아 사용하기 에서 이어집니다. 동적으로 구현체를 선택하는 방법을 알아보자 여러 판매자가 판매하는 상품을 장바구니에 담고 결제를 하였다고 가정해보자.각 판매자에게 구입 요청을 해야할것이다. 이때 판매자에게 할수 있는 행위들이 interface로 정의되어있고, 실제로 요청해야하는 판매자에 따라서 구현체를 바꾸어야한다면?? 어떻게 될까? 예시를 확인해보자 ex)123라면 + 노트북을 장바구니에넣고 한번에 주문 -&gt; 내부적으로는 오뚜기 / LG전자에 구매 요청을 해야야한다주문, 주문취소, 환불이라는 행위자체는 동일하지만 요청해야하는 도메인정보등 세부정보는 다를것이다그리고 이공통점을 판매자라는 인터페이스로, 달라지는 세부적인 부분을 오뚜기/LG전자라는 구현체로 구현했다면? 각 판매자에 해당하는 구현체를 선택하여 요청 로직을 실행해야할것이다. 인터페이스 구현123interface SampleInterface { ...} 1234@Repositorypublic class SampleInterfaceImpl implements SampleInterface { ...} 1234@Repositorypublic class SampleInterfaceOtherImpl implements SampleInterface { ...} 모든 인터페이스를 선언해놓고 분기처리하여 사용하기123456789101112131415161718@Controllerpublic class SampleController { @Autowired private SampleInterfaceImpl basic; @Autowired private SampleInterfaceOtherImpl other; @RequestMapping(path = &quot;/path/Basic&quot;, method = RequestMethod.GET) public void basic() { basic.sampleMethod(); } @RequestMapping(path = &quot;/path/Other&quot;, method = RequestMethod.GET) public void other() { other.sampleMethod(); }} 인터페이스를 Map에 넣어두고 꺼내서 사용하기123456789101112131415161718192021222324@Controllerpublic class SampleController { @Autowired private SampleInterfaceImpl basic; @Autowired private SampleInterfaceOtherImpl other; Map&lt;String, SampleInterface&gt; services; @PostConstruct void init() { services = new HashMap()&lt;&gt;; services.put(&quot;Basic&quot;, basic); services.put(&quot;Other&quot;, other); } @RequestMapping(path = &quot;/path/{service}&quot;, method = RequestMethod.GET) public void method(@PathVariable(&quot;service&quot;) String service){ SampleInterface sample = services.get(service); // remember to handle the case where there's no corresponding service sample.sampleMethod(); }} ApplicationContext 를 활용하는 방법구현체를 bean으로등록하고12345678910111213@Componentpublic class SampleInterfaceImpl implements SampleInterface { public void sampleMethod() { // ... }}@Componentpublic class SampleInterfaceOtherImpl implements SampleInterface { public void sampleMethod() { // ... }}ApplicationContext 의 getBean() 으로 구현체를 로딩하여 사용한다. 1234567891011@Controllerpublic class SampleController { @Autowired private ApplicationContext appContext; @RequestMapping(path = &quot;/path/{service}&quot;, method = RequestMethod.GET) public void method(@PathVariable(&quot;service&quot;) String service){ SampleInterface sample = appContext.getBean(service, SampleInterface.class); sample.sampleMethod(); }} Spring의 DI의 도움을 받는 방법set이나list, map을 통해 자동으로 등록해준다 SampleInterface를 구현한 모든 인터페이스를 리스트에 주입12@Autowiredprivate List&lt;SampleInterface&gt; SampleInterfaces; SampleInterface를 구현한 모든 인터페이스를 맵에 주입한다. key는 구현체의 bean name.12@Autowiredprivate Map&lt;String, SampleInterface&gt; SampleInterfaceMap; 그리고 사용하는곳에서는 맵에서 bean name을통해 선택하여 사용 할 수 있다. 12345678910111213void excuteSampleMethod() { String interfaceName = &quot;&quot; //enum으로 구분하거나, 조건에 맞게 수동으로분기하거나 서비스에맞게 고른다. if (isFirst()) { interfaceName = &quot;SampleInterfaceImpl&quot; } else { interfaceName = &quot;SampleInterfaceOtherImpl&quot; } SampleInterface impl = SampleInterfaceMap.get(interfaceName); impl.sampleMethod();} enum으로 정책정하기위처럼 분기처리하는대신 정책을 정리하는 enum을 두는것도 하나의 방법이다먼저 동적으로 달라지는 종류를 enum으로 정의하고, 구현체의 이름을 적어준다123456789101112public enum SampleType { SAMPLE(&quot;SampleInterfaceImpl&quot;), OTHERS(&quot;SampleInterfaceOtherImpl&quot;) SampleType(String implementation) { this.implementation = implementation; } public String getImplementation() { return this.implementation; }} 이후 선택된 type에 맞게 구현체를 선택하여 기능을 수행한다. 12345void excuteSampleMethod(SampleType sampleType) { SampleInterface impl = SampleInterfaceMap.get(sampleType.getImplementation); impl.sampleMethod();} 내가 선택한 방법마지막에 소개한 Spring의 DI의 도움을 받는 방법 으로 구현하였다.실제로는 로직이 필요하지는 않고 특정 데이터의 종류에 맞게 구현체를 선택만 하면 되는 스팩이었다enum으로 정책을 한곳에서 관리해도되지만, 특정조건을 검사하는 책임을 각 구현체들이 검사하는것이 더 맞다고 생각하였다. 각 구현체에서는 자신을 실행할수 있는지 여부를 검사하는 책임을 가진다 12345public class SampleInterfaceImpl implements SampleInterface { @Overide public boolean isAvailableType(SampleType){ }} 그리고 중간에서 중계해주는 Router를 하나 만들어 주었다 123456789101112@Component@RequiredArgsConstructorpublic class SampleInterfaceRouter { private final List&lt;SampleInterface&gt; sampleInterfaces; //의존성 List로 주입 public SampleInterface getImplemetationByType(SampleType sampleType) { return sampleInterfaces.stream() .filter(e -&gt; e.isAvailableType(sampleType)) //각 구현체에서 판단 .findFirst().orElseThrow(() -&gt; new NotSupportedTypeException()); }} 사용은 아래와같이 하면된다 12345678@AutowiredSampleInterfaceRouter sampleInterfaceRouter;void excuteSampleMethod(SampleType sampleType) { SampleInterface impl = sampleInterfaceRouter.getImplemetationByType(sampleType); impl.sampleMethod();} 참고자료https://stackoverflow.com/a/19027319https://stackoverflow.com/a/37413949https://stackoverflow.com/a/37408117https://stackoverflow.com/q/10534053","link":"/2020/02/07/spring-interface-choice-implements-dynamically/"},{"title":"spring mvc 에서 unit test 구현 (Controller, Service, DAO)","text":"Unit test 구현Spring MVC 구조에서 역할에 따른 Unit test ‘lets party’ 라는 이름으로 프로젝트를 진행중이다.이때 Spring MVC 로 개발을 하였고 이에 따른 테스트를 짜보려 한다. ‘lets party’는 크게 3개의 레이어로 구성되어 있다. Controller : 처리해야 할 데이터를 브라우저에게 받는다. 담당할 service를 선택하여 호출한다 처리한 데이터를 다음 페이지에서 볼 수 있게 셋팅한다. 이동할 페이지를 리턴한다 Service : 데이터를 받아 비지니스 로직을 처리한다. DB의 활용이 필요한 경우 해당 처리를 하는 DAO를 호출한다 DAO db를 활용할 데이터를 받는다 역할을 하는 mapper를 호출하여 처리하게 한다. 이와 같이 역할이 다르다 보니 테스트 하는 방법도 달라진다.기본원칙은 ‘분리’서로가 서로에게 의존하지 않아서, 다른 객체와는 상관 없이 항상 같은 결과가 나와야 한다.(하면서 배웠지만, 적용이 안된 부분도 많다..) 각각의 테스트 방법이 조금씩 다르지만 기본적으로 하는일은 똑같다.목적 : input에 대한 output이 잘 나오는지 확인하기!과정 : 입력값 가정하기 -&gt; 호출하기 -&gt; 검증하기 (호출검증 및 output 검증) ControllerController의 테스트는 크게 2가지를 테스트 하였다 브라우저에서 “/pageName”를 호출 했을때 해당 controller를 호출하는지, 그리고 2xx, 3xx와같은 결과를 받는지 1234mockMvc.perform(get(&quot;/partyDetail&quot;) .param(&quot;partyId&quot;,&quot;1&quot;) .session(httpSession) ).andExpect(status().isOk()); 위 코드는 “/partyDetail” 를 브라우저에서 호출했을때, 해당 controller가 잘 호출 되는지를 확인 한 것이다.get방식으로 전달된 데이터는 param() 으로 받을 수 있고, HttpSession은 .session으로 받는다. Controller에서 재대로 된 Service를 호출 하는지 다른 함수가 잘 호출 되었는지는 Mockito의 verify를 활용하여 검사 할 수 있다. 1verify(partyService).selectParty(1); 위 함수는 partyService.selectParty() 함수가 1이라는 인자값을 통해 호출되었는지 확인하는 함수이다. 그 외에도 다양한 방법으로 함수호출을 test 할 수 있다. 1verify(partyService, times(3)).selectParty(1); times(3) 을 통해 3번 호출 되었는지 검사한다. 1verify(partyService, times(3)).selectParty(anyInt()); anyInt()를 통해서는 ‘1’이라는 인자 외에 int형으로 된 값으로 호출되었는지 테스트 할 수 있다. Serviceservice는 비지니스 로직을 처리하는 부분으로 test도 상대적으로 좀 복잡하다.일반적으로 과정은 다음과 같다 1234567891011@Testpublic void joinPartyFirstJoinTest() { when(partyDAO.getNumOfUserParty(Mockito.any(UserPartyVO.class))).thenReturn(0); when(partyDAO.checkJoin(Mockito.any(UserPartyVO.class))).thenReturn(0); partyService.joinParty(userPartyVO); verify(partyDAO).getNumOfUserParty(Mockito.any(UserPartyVO.class)); verify(partyDAO).insertUserParty(Mockito.any(UserPartyVO.class)); verify(partyDAO).increasePublicParticipantsCount(anyInt());} when().thenReturn() 을 통해 비지니스 로직에서 쓰이는 의존성 있는 함수들의 값들을 미리 세팅한다.이후 함수를 호출하고 (partyService.joinParty(userPartyVO))다른 함수들을 잘 호출 했는지, 기능을 잘수행했는지 검증한다. DAODAO 는 데이터를 가지고 오는것을 목표로 하고있다.이후 교육과정에서 Unit test라기보다는 integration test이라고 부른다.DB에 의존성이 있고, 이를 잘 수행하여 반영이 되는지를 테스트 하기 때문. letsparty에서는 DAO는 한번에 하나의 쿼리만 처리하게 되어 있기 때문에 간단하게 테스트 한다. 단, test 전 후에 DB의 상태가 같아야 하기 때문에 rollback 이 필요한데,rollback은 수동으로 처리하였다 (@Test 와 @Transactional을 활용해서 롤백도 가능 http://credemol.blogspot.com/2011/01/spring-junit-transaction.html) 12345678910111213@Testpublic void insertPartyTest() throws Exception { int sizeOfBeforeInsert = partyDAO.selectAll().size(); partyDAO.insert(partyVO); int insertedPId = partyVO.getPartyId(); int sizeOfAfterInsert = partyDAO.selectAll().size(); assertEquals(&quot;insertTest - inserted party id : &quot;+insertedPId , sizeOfBeforeInsert+1, sizeOfAfterInsert); //clean database partyDAO.deletPartyeById(insertedPId);} insert를 하는 DAO를 테스트하는 코드이다.partyDAO.selectAll(), partyDAO.deletPartyeById() 도 함깨 사용하는데,partyDAO.selectAll() 를 사용하여 insert 전 후에 크기를 비교하여 1개가 잘 들어갔는지 확인한다.이후 partyDAO.deletPartyeById()를 통해 rollback 한다. 이 함수들도 모두 test를 해야한다. selectAll()함수가 잘 동작하지 않는다면 insert는 재대로 test된것이 아니기 때문이다.함깨 테스트를 해도 되는것인지, 그래도 각각을 분리해서 테스트를 해야하는것인지는 잘 모르겠다. 느낀점test코드를 작성하다보니 기존 코드의 단점이나 수정해야할 부분도 함깨 보이기 시작했다.test작성만 하는것이 아니라 리팩토링까지 함깨 하다보니 시간이 꽤 걸렸다 테스트 코드가 하나씩 늘어나니 기분이 좋다","link":"/2019/01/31/spring-unit-test/"},{"title":"온라인 url encoder, decoder ( euc-kr ) &#x2F; JAVA에서 구현방법","text":"euc-kr다양한 회사와 협업을 하다보면 그만큼 다양한 요구사항이 있다.http기반의 api호출이 아닌, socket통신을 하는 회사도 많이있다. 필자가 맡은 서비스의 대부분의 통신이 utf-8로 이루어지고 있다.euc-kr기반의 url encoding을 요청받아 방법에 대해 메모한다. online encoder / decoder필자는 api를 제공받으면 바로 구현에 들어가기보다는 한번씩 호출을 해본다.그리고 호출결과를 명세서와 비교해본다. url encoding이 되어있는경우 아래 사이트를 활용한다.아래 페이지는 char-set을 지정할수 없고 utf-8로 고정되어있다https://meyerweb.com/eric/tools/dencoder/ euc-kr을 char-set으로 선택하여 url encoding/decoding을 하고싶은 경우는 아래 페이지를 활용한다.https://www.webatic.com/url-convertor JAVA 구현예시는 연동후 decode 하는 방법이다. java환경에서 구현시에는 java.net.URLDecoder 를 사용하였다 연동시마다 호출되기때문에 char-set을 static으로 선언해주었다.연동결과를 받아보는 application입장에서는 encoding된 방법을 알필요가없다.getter를통해 캡슐화하였다. 이방법은 checked exception인 UnsupportedEncodingException 를 발생시키기때문에 반드시 handling 해야한다. (단점)기본값을 정하여 리턴하거나, 처리할수 없다면 다시 예외를 던지는 방법도 있을것이다.서비스의 성격마다 다르니 정답은 없다. 123456789101112private static final String CHAR_SET = &quot;euc-kr&quot;;@Overridepublic String getProductName() { try { return URLDecoder.decode(this.productName, CHAR_SET); } catch (UnsupportedEncodingException e) { //return null; //return Strings.EMPTY; //throw new CannotDecodeException(); }}","link":"/2020/09/10/url-encoding-decoding-euckr/"},{"title":"대용량 데이터 다운로드시 oom 방지 가이드","text":"웹서비스를 하다보면 데이터를 조회하고, 그데이터를 일괄 다운로드하는 니즈가 생긴다.(특히 어드민)이런경우 서버 성능에따라 oom(out of memory)이 발생할 수 있다.자주 생기는 상황으로는 대량의 데이터를 조회한 다음, 이를 엑셀파일로 내려받는경우가 있다.이 경우를 예시로 원인과 해결법을 알아보고자 한다. 원인 db에서 데이터를 가지고와서 객체로 들고있는 단계에서 OOM workbook을 생성해 데이터체우다가 OOM 메모리에 담고있는것을 전송하는 단계까지 메모리를 계속 holding! - OOM 확률 up! 개선포인트A. db에서 한번에 가지고오는 데이터 크기(fetch size)를 조절한다B. db에서 가지고온 데이터를 통체로 들고있지 않고 나누어 처리한다.C. 엑셀에 내용을 체우다가 일정 사이즈 이상 되면 Disk에 쓰도록 한다 (기존에도 되어있음)D. 임시파일은 바로바로 삭제하도록한다 (삭제를 명시적으로 하지 않으면 tomcat 내려갈때 삭제됨. 강제종료시는 삭제 안될 가능성)E. 다운로드 중복클릭 방지 해결법(1) -&gt; (A),(B)(2),(3) -&gt; (C)부가적인 개선사항 : (D), (E) 요점개선포인트에서 밝힌것처럼, 메모리를 효율적으로 사용하기 위한 방법들을 적용한다. db에서 데이터를 가지고오는 부분 (read) 저장하는 부분 (write) read 와 write가 전체데이터가아닌 부분에 적용되어야하고read된 데이터를 write 하고나서, 다음데이터를 처리하는 방식으로 진행해야한다. 123456789101112131415161718public SXSSFWorkbook createDownloadFile(R request) { Page&lt;T&gt; result; SXSSFWorkbook workbook = initializer.initialize(flushSize); Pageable pageable = PageRequest.of(0, defaultPageable.getPageSize()); try { do { result = reader.read(request, pageable); writer.write(workbook, result.getContent()); pageable = pageable.next(); } while (result.hasNext()); } catch (Exception e) { workbook.dispose(); throw e; } return workbook;} 아래부터는 실제 적용 예시를 소개한다. 예시환경 spring mybatis poi apache tomcat fetch size를 조절 &amp; result handler 사용하는방법mybatis 를 쓰는경우 ResultHandler 를 쓸 수 있음.이 ResultHandler 안에서 apache poi 를 활용하여 다운로드 하도록 설정 Service12345List&lt;Object&gt; getObjects(Object object) { YourResultHandler resultHandler = new YourResultHandler(); yourMapper.getObjects(object, resultHandler); return resultHandler.getResults();} Dao123public interface YourDao { void getObjects(@Param(&quot;param1&quot;) Object object, ResultHandler handler);} mapper.xmlfetch size 가 작을수록 OOM 발생가능성은 낮아지지만, 성능하락이 있음.조회되는 데이터의 크기와,쿼리의 속도를 고려해서 fetchSize를 고려해야한다. 123&lt;select id=&quot;SELECT_TABLE&quot; parameterType=&quot;Object&quot; fetchSize=&quot;100&quot; resultType=&quot;List&quot;&gt; SELECT * FROM TABLE WHERE NAME = #{object.value}&lt;/select&gt; apache poi 사용엑셀 파일 데이터 생성시 임시 file 을 생성하는 방식임 1Workbook wb = new SXSSFWorkbook(1000); 이후 임시 파일을 바로 삭제 1((SXSSFWorkbook)wb).dispose(); excel file을 생성하지 않고 response로 바로 전송 (?)엑셀파일을 만든다움 클라이언트에 전송하게되면 파일크기만큼 메모리를 사용한다. + 추가적으로 연속클릭을 방지하도록 작성하기 (jquery.fileDownload) 12345678public void download(HttpServletResponse response, SXSSFWorkbook sxssfWorkbook) { String fileName = &quot;data&quot; + new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(new Date()) + &quot;.xlsx&quot;; response.setHeader(&quot;Set-Cookie&quot;, &quot;fileDownload=true; path=/&quot;); response.setHeader(&quot;Content-Disposition&quot;, String.format(&quot;attachment; filename=\\&quot;&quot;+fileName+&quot;\\&quot;&quot;)); sxssfWorkbook.write(response.getOutputStream());} 123456789101112131415&lt;div&gt; &lt;input type=button id=&quot;insert&quot; value=&quot;insert&quot;&gt; &lt;input type=button id=&quot;download&quot; value=&quot;download&quot;&gt; &lt;input type=button id=&quot;download2&quot; value=&quot;download2&quot;&gt;&lt;/div&gt;&lt;!-- progressbar --&gt;&lt;div title=&quot;Data Download&quot; id=&quot;preparing-file-modal&quot; style=&quot;display: none;&quot;&gt; &lt;div id=&quot;progressbar&quot; style=&quot;width: 100%; height: 22px; margin-top: 20px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- error --&gt;&lt;div title=&quot;Error&quot; id=&quot;error-modal&quot; style=&quot;display: none;&quot;&gt; &lt;p&gt;생성실패.&lt;/p&gt;&lt;/div&gt; 1234567891011121314$(&quot;#download2&quot;).on(&quot;click&quot;, function () { var $preparingFileModal = $(&quot;#preparing-file-modal&quot;); $preparingFileModal.dialog({modal: true}); $(&quot;#progressbar&quot;).progressbar({value: false}); $.fileDownload(&quot;/data/test/download2.json&quot;, { successCallback: function (url) { $preparingFileModal.dialog('close'); }, failCallback: function (responseHtml, url) { $preparingFileModal.dialog('close'); $(&quot;#error-modal&quot;).dialog({modal: true}); } }); return false; }); 실험실험방법 테스트 페이지 작성 insert : 데이터넣기 download : 기존로직 download2 : 개선로직 data insert 약 40만건 데이터 수동으로 넣음 before / after 비교 할 수 있는 test api 2개 작성 각버튼을 연속으로 5회씩 눌러 메모리 변화테스트 (테스트를위해 중복클릭 허용) 메모리 변화 모니터링은 VisualVM 기타정보 Object size : 246M excel file size : 43M 비교memorybefore after 비교 개선전 2번째 GC구간을 보면 메모리가 감소하지 않는 영역이있다. (약1.8G) 요청이 몰리거나 데이터가 더 커지면 충분히 OOM이 발생 할 수 있다. 개선후 GC를 하는구간을 보면 메모리를 거의 사용하지 않는것을 확인 할 수 있다. 심지어 GC하기전에도 1.5G이상 메모리가 올라가지않는다. temp filesbefore 다운로드 후 파일이 계속 남아있음 GC를 하면 사라짐 강제종료시 계속 남아있음. after 다운로드 후 바로 삭제됨. 참고자료http://dymn.tistory.com/20http://dreamsea77.tistory.com/221https://offbyone.tistory.com/70http://jaycee-p.tistory.com/12http://www.docjar.com/html/api/org/apache/poi/xssf/usermodel/examples/BigGridDemo.java.html (보충할 부분이나 잘못된부분이 있다면 연락주시기 바랍니다.)","link":"/2019/02/28/%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%97%91%EC%85%80%ED%8C%8C%EC%9D%BC-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C-oom-%EB%B0%A9%EC%A7%80-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"title":"백준 자바 제출 템플릿 포멧","text":"코딩테스트각종 it회사에서 개발자를 채용할때 코딩테스트 전형을 실시하고있다코딩테스트를 준비하기위해서는 다양한 알고리즘을 실전처럼 풀어보는것이 중요하다.이때 다양한 문제를 풀어보고, 내가 제출한 답이 맞는지 테스트를 해볼 수 있는사이트들이 있다. 백준 : https://www.acmicpc.net 프로그래머스 : https://programmers.co.kr 각 사이트마다, 언어마다 인풋/아우풋을 다루는 방법이 다르므로 숙지해야한다.이포스트는 백준에서 자바코드를 제출하는 방법에 대해 다룬다. 백준에서 자바코드 제출 포멧 file 백준 사이트에서는 채점시 소스코드를 입력받고, Main.java 라고 가정하여 받고있다. 따라서 class 이름도 Main으로 지정해주어야 정상적으로 작동한다. input standard input (stdin, system in)을 통해서 입력한다. scanner를 통해 받아주자 output 답을 stdard output (stdout, system out) 으로 나오는 결과를 보고 체점한다. 이를 종합하여 아래와 같이 재출하면된다.아래는 1000번 문제- 단순 덧샘을 하는 문제의 예시이다.https://www.acmicpc.net/problem/1000 1234567891011121314151617181920import java.io.IOException;import java.util.Scanner;public class Main { public static void main(String[] args) throws IOException { //input Scanner scanner = new Scanner(System.in); int first = scanner.nextInt(); int second = scanner.nextInt(); //logic int answer = first + second; //output System.out.println(answer); }} 예제 코드 실제 제출화면","link":"/2019/10/20/%EB%B0%B1%EC%A4%80-%EC%9E%90%EB%B0%94-%EC%A0%9C%EC%B6%9C-%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%8F%AC%EB%A9%A7/"},{"title":"gzip:: 아파치,nginx 설정으로 웹페이지 로딩 속도를 빠르게","text":"프론트 성능 개선프론트 성능개선을 위해 많이 쓰이는 것중 하나가 바로 Gzip서버에서 html, javascript, css 등을 압축해줘서 리소스를 받는 로딩시간을 줄여줌으로서 성능 개선예전 프로젝트에서 Gzip에 minify나 concat, cache을 더하여 적용하였더니 이전보다 약 85%의 성능향상이 있었습니다. 웹개발을 하게 되면 필수적인 옵션이라고 할 수 있습니다. Gzip - 위키피디아 gzip은 파일 압축에 쓰이는 응용 소프트웨어이다. gzip은 GNU zip의 준말이며, 초기 유닉스 시스템에 쓰이던 압축 프로그램을 대체하기 위한 자유 소프트웨어이다. gzip은 Jean-loup Gailly와 마크 애들러가 만들었다. 버전 0.1은 1992년 10월 31일에 처음 공개되었으며, 버전 1.0이 1993년 2월에 뒤따라 나왔다. 오픈BSD의 gzip 버전은 더 오래된 압축 프로그램을 기반으로 하고 있으며, 오픈BSD 3.4에 추가되었다. 아파치 설정 LoadModule deflate_module modules/mod_deflate.so 주석 해제 1234567891011121314151617181920&lt;IfModule mod_deflate.c&gt; AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE text/css AddOutputFilterByType DEFLATE application/xml AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE application/rss+xml AddOutputFilterByType DEFLATE application/javascript AddOutputFilterByType DEFLATE application/x-javascript DeflateCompressionLevel 9 BrowserMatch ^Mozilla/4 gzip-only-text/html BrowserMatch ^Mozilla/4\\.0[678] no-gzip BrowserMatch \\bMSIE !no-gzip !gzip-only-text/html SetEnvIfNoCase Request_URI \\.(?:gif|jpe?g|png|bmp|zip|gz|rar|7z)$ no-gzip dont-vary&lt;/IfModule&gt; nginx설정1234gzip on; gzip_disable &quot;msie6&quot;; gzip_comp_level 9; gzip_types text/plain text/css application/javascript application/json;","link":"/2019/02/01/%EC%95%84%ED%8C%8C%EC%B9%98-nginx-%EC%84%A4%EC%A0%95%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84%EB%A5%BC-%EB%B9%A0%EB%A5%B4%EA%B2%8C/"},{"title":"[Zipkin] 사용법 가이드 - MSA 요청추적 (springboot&#x2F; sleuth&#x2F; grpc&#x2F; http)","text":"tracing이 필요한 이유Monolithic 시스템의 경우 클라이언트의 요청을 받으면 하나의 스레드에서 모든 요청을 실행하므로 로그를 확인하기 쉽다는 장점이 있습니다.그에 반해 MSA의 경우에는 각 서비스의 복잡도가 낮아지고 역할 분담이 용이하지만 클라이언트의 요청을 받았을 때 여러 개의 마이크로 서비스 간에 통신이 발생해 로그를 확인하기 어려운 문제가 있습니다.이를 해결하기 위한 어플리케이션 간 분산 추적을 위한 표준이 OpenTracing이며, 대표적은 구현체는 zipkin과 jaeger가 있습니다. 클라이언트가 서버로 호출한 하나의 호출을 Trace라고 했을 때, 서비스 컴포넌트간의 호출을 Span이라고 한다.각 서비스 컴포넌트들은 하나의 클라이언트 호출을 추적하기 위해서 같은 Trace Id를 사용하고,각 서비스간의 호출은 각각 다른 SpanId를 사용합니다. 이렇게 함으로써 전체 트렌젝션 시간을 Trace로 추적이 가능하고, 각 서비스별 구간 시간은 Span으로 추적할 수 있습니다. 개발환경 spring-boot 2.5.4 spring-cloud-sleuth spring-cloud-sleuth-zipkin grpc, http 예제코드는 아래 github에서 확인할수 있습니다.https://github.com/HyeonGuJ/spring-boot-sleuth-zipkin-grpc-sample 적용하기촤상위 build.gradle에 의존성 추가build.gradle1234567891011121314151617buildscript { ... dependencies { classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.16' }}subprojects { apply plugin: 'com.google.protobuf' dependencies { ... //zipkin implementation 'org.springframework.cloud:spring-cloud-sleuth-zipkin' implementation 'org.springframework.cloud:spring-cloud-starter-sleuth' ... }} 각 서비스의 application.yml에 zipkin collector 정보 추가본 예제에서는 zipkin collector server를 9411 port로 설정했다고 가정합니다. 1234567891011121314#application.ymlserver: port: 8082spring: application: name: privateService sleuth: sampler: probability: 1.0 zipkin: base-url: http://localhost:9411 service: name: privateService grpc 서비스들 셋팅하기spring-cloud-sleuth 의 문서를 기반으로 구현했습니다.https://docs.spring.io/spring-cloud-sleuth/docs/current/reference/html/integrations.html#sleuth-rpc-grpc-variant1-integration grpc serverbuild.gradle에 의존성을 추가12345678910111213141516171819202122232425262728293031dependencies { implementation 'io.github.lognet:grpc-spring-boot-starter:4.5.5' implementation 'io.zipkin.brave:brave-instrumentation-grpc'} sourceSets { src { main { java { srcDirs 'build/generated/source/proto/main/grpc' srcDirs 'build/generated/source/proto/main/java' } } }} protobuf { protoc { artifact = &quot;com.google.protobuf:protoc:3.12.0&quot; } plugins { grpc { artifact = &quot;io.grpc:protoc-gen-grpc-java:1.39.0&quot; } } generateProtoTasks { all()*.plugins { grpc {} } }} application.yml 에 grpc.port를 설정해줍니다1234567891011121314grpc: port: 8084spring: application: name: grpcServer sleuth: sampler: probability: 1.0 zipkin: base-url: http://localhost:9411 service: name: grpcServer HelloService.proto 를 미리 작성했습니다.build 후 생성된 소스코드를 사용할수 있는 상태임을 가정합니다. 요청시 처리해야할 로직을 구현하고 @GRpcService를 통해 노출 할 수 있습니다 123456789101112131415161718192021222324252627//HelloService.java@Slf4j@GRpcServicepublic class HelloService extends HelloServiceGrpc.HelloServiceImplBase { @Override public void sayHello(HelloRequest request, StreamObserver&lt;HelloResponse&gt; responseObserver) { log.info(&quot;[S4] called&quot;); //get message String message = new StringBuilder().append(&quot;hello &quot;) .append(request.getName()) .toString(); //build response HelloResponse response = HelloResponse.newBuilder() .setMessage(message) .build(); //send message and complete. responseObserver.onNext(response); responseObserver.onCompleted(); }} grpc client서버측과 마찬가지로 build.gradle 을 준비합니다(동일하게 셋팅, 예제 생략) client에서는 server측과 연동하기위해 channel을 열고, stub을 생성후 request를 전송해야합니다. channel을 열고 stub을 생성성하는 예제입니다.12345678910111213141516//GrpcClientConfig.java@Configurationpublic class GrpcClientConfig { private final SpringAwareManagedChannelBuilder springAwareManagedChannelBuilder; public GrpcClientConfig(SpringAwareManagedChannelBuilder springAwareManagedChannelBuilder) { this.springAwareManagedChannelBuilder = springAwareManagedChannelBuilder; } @Bean public HelloServiceGrpc.HelloServiceBlockingStub helloServiceBlockingStub() { ManagedChannel channel = this.springAwareManagedChannelBuilder.forAddress(&quot;localhost&quot;, 8084).usePlaintext().build(); return HelloServiceGrpc.newBlockingStub(channel); }} 주의ManagedChannel 을 생성할때 반드시 SpringAwareManagedChannelBuilder로 해야합니다.SpringAwareManagedChannelBuilder로 생성해야만 Spring에서 grpc 를 inject 할 수 있습니다.그렇지 않으면 trace id가 전달되지 않습니다. (경험담)https://docs.spring.io/spring-cloud-sleuth/docs/current/reference/html/integrations.html#sleuth-rpc-grpc-variant1-client-integration test구조외부 요청을 받는 public 서버가있고, 내부적으로 private, grpcClient를 호출grpcClient는 http를통해 요청을받고, grpc로 grpcServer와 통신합니다이 서버들은 모두 zipkin collector server로 데이터를 전송합니다 (출처 zipkin 공식 홈페이지 : https://zipkin.io/pages/architecture.html) 자세한 실행방법은 github - readme.md 를 참고하세요https://github.com/HyeonGuJ/spring-boot-sleuth-zipkin-grpc-sample logs 로그상에 trace id가 모두 동일하게 잡히고, span id 는 다르게 보이는것을 확인 할 수 있습니다. zipkin 에서 확인하기필자는 docker를 이용해 zipkin을 실행했으며 별도의 설정을 하지않아도 dashboard를 제공하기때문에 이를 통해 확인했습니다. 1docker run -d -p 9411:9411 openzipkin/zipkin http://localhost:9411/zipkin/traces/{traceId} 위와같이 성공적으로 나오는 모습을 확인 할 수 있었다.비동기 요청의 경우 아래와같이 동시에 실행되는것 또한 볼 수 있다","link":"/2021/07/20/spring-boot-sleuth-zipkin-grpc-sample/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"intellij","slug":"intellij","link":"/tags/intellij/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"jpa","slug":"jpa","link":"/tags/jpa/"},{"name":"querydsl","slug":"querydsl","link":"/tags/querydsl/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"ddd","slug":"ddd","link":"/tags/ddd/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"exception","slug":"exception","link":"/tags/exception/"},{"name":"enum","slug":"enum","link":"/tags/enum/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"jenkin","slug":"jenkin","link":"/tags/jenkin/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"spring initializr","slug":"spring-initializr","link":"/tags/spring-initializr/"},{"name":"mustache","slug":"mustache","link":"/tags/mustache/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"excel","slug":"excel","link":"/tags/excel/"},{"name":"front","slug":"front","link":"/tags/front/"},{"name":"baekjoon","slug":"baekjoon","link":"/tags/baekjoon/"},{"name":"online_judge","slug":"online-judge","link":"/tags/online-judge/"},{"name":"sleuth","slug":"sleuth","link":"/tags/sleuth/"},{"name":"zipkin","slug":"zipkin","link":"/tags/zipkin/"},{"name":"grpc","slug":"grpc","link":"/tags/grpc/"},{"name":"tracing","slug":"tracing","link":"/tags/tracing/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"coding-test","slug":"coding-test","link":"/categories/coding-test/"},{"name":"MSA","slug":"MSA","link":"/categories/MSA/"}]}